<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NOT DONE</title>
  <style>  
    html, body { margin:0; height:100%; background:#0b1220; overflow:hidden; }
    #hud {
      position: fixed; top: 12px; left: 12px;
      font: 14px ui-monospace, Consolas, monospace; color: #e9eefc;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 10px;
      user-select: none; max-height: 95vh; overflow-y: auto; width: max-content;
    }
    #hud input[type=range]{ width: 140px; vertical-align: middle; margin: 4px 6px; }
    #cross { position: fixed; top: 50%; left: 50%; width: 18px; height: 18px; margin: -9px 0 0 -9px; pointer-events: none; }
    #cross:before, #cross:after { content: ""; position: absolute; background: #e9eefc; }
    #cross:before { left: 8px; top: 0; width: 2px; height: 18px; }
    #cross:after  { top: 8px; left: 0; height: 2px; width: 18px; }
    .hotCell.selected {
      outline: 2px solid rgb(255, 255, 255);
    }


    /* Hotbar bar */
    #hotbar{
      position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%);
      padding: 6px 8px; background: rgba(0,0,0,.35); border-radius: 10px;
      backdrop-filter: blur(2px);
    }
    #hotbarSlots{ display: grid; grid-template-columns: repeat(9, 42px); gap: 6px; }
    .hotCell{
      width: 42px; height: 42px; border-radius: 6px; background: rgba(255,255,255,.06);
      position: relative; box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .hotCell.selected{ outline: 2px solid yellow; outline-offset: -2px; }
    .hotIcon{
      position:absolute; inset:6px; background-image:url("atlas.png");
      background-size: 400% 400%; /* 4x4 atlas → we set pos via setIconBG */
      image-rendering: pixelated;
      visibility: hidden; 
    }
    .hotCount{
      position:absolute; right:4px; bottom:2px; font: 12px ui-monospace, monospace; color:white;
      text-shadow: 0 1px 2px rgba(0,0,0,.8);
    }
    #invPanel {
      position: fixed; inset: 0; display: none; place-items: center;
      background: rgba(0,0,0,.35); backdrop-filter: blur(2px); z-index: 5000;
    }
    #invPanel .invCard {
      background: rgba(20,20,24,.9);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    #invTitle {
      font: 14px ui-monospace, monospace; color: #e9eefc; margin-bottom: 8px; opacity:.8;
    }
    #invBackpack {
      display: grid; grid-template-columns: repeat(9, 42px); gap: 6px;
    }
    #invBackpack .hotCell { background: rgba(255,255,255,.06); }


    /* 
    #invCursor{
      width: 32px; height: 32px; 
    }

    #invCursor .hotIcon{
      position: relative;          
      inset: 0;
      width: 100%; height: 100%;
      background-image: url("atlas.png");
      background-size: 400% 400%; 
      image-rendering: pixelated;
    }

    #invCursor .hotCount{
      position: absolute;
      right: 2px;
      bottom: 2px;
      font: 12px ui-monospace, monospace;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,.8);
    }
    */
  </style>
</head>
<body>
  <!-- HUD UI -->
  <div id="hud">
    <div><b>Voxel Prototype</b> — click to lock mouse • F3 toggles HUD</div>
    <div>WASD move • Space jump • Shift sprint • Left: break • Right: place • 1–4 block • R: regen</div>
    <div id="info"></div>
    <hr>
    <label><input type="checkbox" id="betterFps"> Better FPS mode</label>
    <hr>
    <b>Movement</b><br>
    Gravity <input id="gSlider" type="range" min="-20" max="0" step="0.1" value="-19"> <span id="gVal"></span><br>
    JumpVel <input id="jSlider" type="range" min="0" max="20" step="0.1" value="6.7"> <span id="jVal"></span><br>
    WalkSpd <input id="wSlider" type="range" min="0" max="500" step="1" value="70"> <span id="wVal"></span><br>
    <hr>
    <b>Render</b><br>
    RenderDist <input id="rSlider" type="range" min="0" max="10" step="1" value="6"> <span id="rVal"></span><br>
    Builds/frame <input id="bSlider" type="range" min="1" max="24" step="1" value="6"> <span id="bVal"></span><br>
  </div>

  <div id="cross"></div>
  <!-- Hotbar -->
  <div id="hotbar">
    <div id="hotbarSlots"></div>
  </div>
  <!-- STEP 4: cursor ghost -->
  <div id="invCursor" style="display:none; pointer-events:none; position:fixed; translate:-50% -50%; z-index:9999;">
    <div class="hotIcon" style="width:34px; height:34px;"></div>
    <div class="hotCount" style="right:0; bottom:-2px; position:absolute;"></div>
  </div>
  <!-- Inventory panel -->
  <div id="invPanel" style="display:none">
    <div class="invCard">
      <div id="invTitle">Inventory</div>
      <div id="invBackpack"></div>
    </div>
  </div>
  <div id="hearts" style="font-size:24px; line-height:1.2"></div>
    <div id="food"   style="font-size:24px; line-height:1.2"></div>
    <div id="hurtOverlay"
         style="position:fixed;top:0;left:0;width:100%;height:100%;
                background:red;opacity:0;pointer-events:none;"></div>


  <script type="module">
    import * as THREE from "https://esm.sh/three@0.160.0";
    import { Sky }   from "https://esm.sh/three@0.160.0/examples/jsm/objects/Sky.js";



    // Physics (per-second)
    let GRAVITY  = -19;  
    let JUMP_VEL =  6.7;   
    // Horizontal accel (per-second). With DRAG=6 these settle to ~a/DRAG speed.
    let WALK     = 50;    
    // friction
    let FRICTION_GROUND = 0.86;
    let FRICTION_AIR    = 0.89;
    // --- Biome & shape tuning ---
    let BIOME_SCALE     = 0.0190;
    let WARP_SCALE      = 0.012;
    let WARP_STRENGTH   = 18.0;
    // Plains
    let PLAINS_BASE     = 23;
    let PLAINS_WOBBLE   = 3.0;
    // Hills
    let HILLS_SCALE     = 0.015;
    let HILLS_AMP       = 20;
    // Mountains (ridged)
    let MOUNT_SCALE     = 0.005;
    let MOUNT_RIDGES    = 220;
    // “Hilly patches”
    let SPOT_SCALE      = 0.012;
    let SPOT_THRESHOLD  = 0.55;
    let SPOT_AMPLITUDE  = 30;
    // World management
    let GRID_RADIUS = 4;
    let BUILDS_PER_FRAME = 12;


    /* ===== Movement tuning ===== */
    let RUN_MULT      = 1.5;  // sprint factor (Z)
    let CROUCH_MULT   = 0.5;  // crouch factor (Shift)
    let isRun = false, isCrouch = false;
    let eyeY = 1.62; // smoothed eye height
    let REACH_DISTANCE = 6;
    let WORLD_SEED = 16 + Math.floor(Math.random() * 2**31); 

    /* ===== Config ===== */
    const CHUNK = { X:16, Y:256, Z:16 };
    const BLOCK = { AIR:0, STONE:1, GRASS:2, DIRT:3, GLASS:4, LOG:5, LEAVES:6};
    let CURRENT_BLOCK = BLOCK.STONE;
    const BLOCK_TRANSPARENT = {
      [BLOCK.AIR]: true,
      [BLOCK.LEAVES]: true,
      [BLOCK.GLASS]: true,
    };
    // -------- 3D FBM cave field (domain-warped value noise) --------
    function hash3i(x,y,z, seed=WORLD_SEED){
      // tiny 32-bit integer hash → [0,1)
      let h = x*374761393 ^ y*668265263 ^ z*2147483647 ^ (seed|0);
      h ^= h<<13; h ^= h>>>17; h ^= h<<5;
      return ((h>>>0) / 4294967296);
    }

    function value3(x,y,z){
      // lattice value noise with trilinear blend
      const xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z);
      const xf=x-xi, yf=y-yi, zf=z-zi;
      const s=(t)=>t*t*(3-2*t); // smoothstep
      const c000=hash3i(xi,yi,zi),     c100=hash3i(xi+1,yi,zi);
      const c010=hash3i(xi,yi+1,zi),   c110=hash3i(xi+1,yi+1,zi);
      const c001=hash3i(xi,yi,zi+1),   c101=hash3i(xi+1,yi,zi+1);
      const c011=hash3i(xi,yi+1,zi+1), c111=hash3i(xi+1,yi+1,zi+1);
      const u=s(xf), v=s(yf), w=s(zf);
      const x00 = c000*(1-u)+c100*u, x10=c010*(1-u)+c110*u;
      const x01 = c001*(1-u)+c101*u, x11=c011*(1-u)+c111*u;
      const y0  = x00*(1-v)+x10*v,   y1 = x01*(1-v)+x11*v;
      return y0*(1-w)+y1*w; // [0,1]
    }

    function fbm3(x,y,z, oct=4, lac=2.0, gain=0.5){
      let a=0, amp=1, freq=1;
      for (let i=0;i<oct;i++){
        a += value3(x*freq, y*freq, z*freq)*amp;
        freq *= lac; amp *= gain;
      }
      return a / ((1 - Math.pow(gain, oct)) / (1 - gain)); // ~normalize
    }

    function sampleCave(wx, wy, wz){
      // scale world → noise space
      let sx = wx*0.045, sy = wy*0.045, sz = wz*0.045;
    
      // domain warp (adds twisty tunnels)
      const warp = 0.3;
      const wx1 = value3(sx*1.7, sy*1.7, sz*1.7)*2-1;
      const wy1 = value3(sx*1.7+100, sy*1.7-50, sz*1.7+30)*2-1;
      const wz1 = value3(sx*1.7-70, sy*1.7+80, sz*1.7-20)*2-1;
      sx += wx1*warp; sy += wy1*warp; sz += wz1*warp;
    
      // fbm field
      const f = fbm3(sx, sy, sz, 5, 2.0, 0.55); // 5 octaves
      // height bias: fewer caves near surface, more deep
      const depth = Math.max(0, (wy - 24) / 64); // 0 at y≈24 → 1 by y≈88
      const thresh = 0.58 + depth*0.10;          // deeper = more caves
    
      return f > thresh; // true → carve air
    }

    // -------- carve a few worm tunnels inside this chunk --------
    function carveWormsInChunk(c, count=3){
      const baseX = c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
      const R = (min,max)=>min + Math.random()*(max-min);
    
      for (let i=0;i<count;i++){
        // start somewhere underground in this chunk
        let x = baseX + R(0, CHUNK.X);
        let y = R(8, Math.min(56, CHUNK.Y-8));
        let z = baseZ + R(0, CHUNK.Z);
      
        // random heading
        let yaw = R(0, Math.PI*2), pitch = R(-0.3, 0.3);
        const len = R(40, 90);         // segments
        const rad = R(1.2, 2.2);       // tunnel radius
      
        for (let t=0; t<len; t++){
          // carve a small cylinder at (x,y,z)
          const r2 = rad*rad;
          const cx = Math.floor(x), cy=Math.floor(y), cz=Math.floor(z);
          for (let yy = -Math.ceil(rad); yy<=Math.ceil(rad); yy++){
            const ay = cy+yy; if (ay<1 || ay>=CHUNK.Y-1) continue;
            for (let xx = -Math.ceil(rad); xx<=Math.ceil(rad); xx++){
              for (let zz = -Math.ceil(rad); zz<=Math.ceil(rad); zz++){
                if (xx*xx + yy*yy + zz*zz <= r2){
                  const ax = cx+xx, az = cz+zz;
                  // ensure inside this chunk
                  if ((ax>>0)>>>0 >= baseX && (ax>>0) < baseX+CHUNK.X &&
                      (az>>0)>>>0 >= baseZ && (az>>0) < baseZ+CHUNK.Z){
                    const lx = ax - baseX, lz = az - baseZ;
                    c.blocks[idx(lx, ay, lz)] = BLOCK.AIR;
                  }
                }
              }
            }
          }
          // update heading with gentle noise so it meanders
          const s = 0.09, n = value3(x*s, y*s, z*s)*2-1;
          yaw   += n*0.25;
          pitch += (value3(x*s+77, y*s-33, z*s+11)*2-1)*0.08;
          pitch = Math.max(-0.7, Math.min(0.7, pitch));
          // move forward
          x += Math.cos(yaw)*Math.cos(pitch)*1.2;
          y += Math.sin(pitch)*1.0;
          z += Math.sin(yaw)*Math.cos(pitch)*1.2;
        }
      }
    }



    /* ===== STEP 1: Item Registry (barebones, MC-style) ===== */
    // numeric id ↔ string id (optional sugar)
    const BLOCK_NAME = {
      [BLOCK.AIR]:   "air",
      [BLOCK.STONE]: "stone",
      [BLOCK.GRASS]: "grass",
      [BLOCK.DIRT]:  "dirt",
      [BLOCK.GLASS]: "glass",
      [BLOCK.LOG]:   "oak_log",
      [BLOCK.LEAVES]:"oak_leaves",
    };

    // registry entries (what MC would call “item defs”)
    const ITEM_REG = new Map([
      ["air",        { id:"air",        maxStack:64, tags:new Set(["air"]) }],
      ["stone",      { id:"stone",      maxStack:64, tags:new Set(["block"]) }],
      ["dirt",       { id:"dirt",       maxStack:64, tags:new Set(["block"]) }],
      ["grass",      { id:"grass",      maxStack:64, tags:new Set(["block"]) }],
      ["glass",      { id:"glass",      maxStack:64, tags:new Set(["block","transparent"]) }],
      ["oak_log",    { id:"oak_log",    maxStack:64, tags:new Set(["block","log","wood"]) }],
      ["oak_leaves", { id:"oak_leaves", maxStack:64, tags:new Set(["block","leaves"]) }],
    ]);

    // helpers
    // === 1.8-style damage camera shake ===
    const HurtCam = {
      t: 0, dur: 0.25,  // quarter second effect
      dir: 1             // direction (left/right)
    };

    // kick it when you take damage; strength ~= hearts lost / 2
    function triggerHurtShake(strength = 1){
      // tune these to taste
      const baseDur = 0.42;              // how long the effect lasts
      const k = Math.min(1.5, Math.max(0.2, strength)); // clamp
      HurtCam.dur = baseDur * (0.6 + 0.4*k);
      HurtCam.t   = HurtCam.dur;
      HurtCam.freq = 12 + 6*Math.random();          // a bit of variety
      HurtCam.ampYaw   = 0.015 * k;                 // small horizontal wobble
      HurtCam.ampPitch = 0.030 * k;                 // stronger pitch kick
      HurtCam.ampRoll  = 0.018 * k;                 // screen tilt
    }

    // returns additive {yaw,pitch,roll} for this frame
    function stepHurtShake(dt){
      if (HurtCam.t <= 0) return { yaw:0, pitch:0, roll:0 };
      HurtCam.t -= dt;
    
      // normalized time left (0..1), squared falloff feels nice
      const u  = Math.max(0, HurtCam.t / HurtCam.dur);
      const env = u*u;                               // exponential-ish decay
      const w  = HurtCam.freq * 2*Math.PI;
    
      // phase that moves as time elapses
      const ph = (HurtCam.dur - HurtCam.t);
    
      return {
        yaw:   env * HurtCam.ampYaw   * Math.sin(w * ph * 0.92),
        pitch: env * HurtCam.ampPitch * Math.cos(w * ph * 1.00),
        roll:  env * HurtCam.ampRoll  * Math.sin(w * ph * 1.12)
      };
    }

    function itemIdFromBlockId(numId){
      const name = BLOCK_NAME[numId] || "air";
      return name;
    }

    function getItemDef(itemId){
      return ITEM_REG.get(itemId) || ITEM_REG.get("air");
    }

    function maxStackOf(itemId){
      return getItemDef(itemId).maxStack ?? 64;
    }

    // stackability rule (same id + no NBT yet)
    function canStackTogether(a, b){
      if (!a || !b) return false;
      if (!a.id || !b.id) return false;
      if (a.id !== b.id)  return false;
      // (later: compare NBT/damage/enchants)
      return true;
    }
    /* ===== STEP 2: ItemStack helpers (minimal, MC-style) ===== */
    // factory (safe normalize)
    function makeStack(itemId = null, count = 0, nbt = null){
      if (!itemId || count <= 0) return { id:null, count:0, nbt:null };
      const max = maxStackOf(itemId) ?? 64;
      return { id: itemId, count: Math.min(count|0, max), nbt: nbt ?? null };
    }

    // queries
    function isEmpty(stack){ return !stack || !stack.id || stack.count <= 0; }
    function spaceLeft(stack){
      if (isEmpty(stack)) return 0;           // empty slots don't have "space" for merge; use "fill empty" step for that
      const max = maxStackOf(stack.id) ?? 64;
      return Math.max(0, max - (stack.count|0));
    }

    // stackability (reuse registry rule)
    function canStack(a, b){
      if (isEmpty(a) || isEmpty(b)) return false;
      return canStackTogether(a, b);          // same id (+ same NBT later)
    }

    // mutation helpers (intentionally small + explicit)

    // take up to n items out of `stack`, returns how many actually taken.
    // (mutates `stack.count`, clears id if it hits 0)
    function takeFrom(stack, n){
      if (isEmpty(stack) || n <= 0) return 0;
      const k = Math.min(stack.count|0, n|0);
      stack.count -= k;
      if (stack.count <= 0){ stack.id = null; stack.count = 0; stack.nbt = null; }
      return k;
    }

    // put up to `srcCount` items into `dst` (must be same-id stack, not empty slot).
    // returns leftover (0 means fully merged).
    function mergeInto(dst, srcCount){
      if (!dst || srcCount <= 0) return srcCount|0;
      const room = spaceLeft(dst);
      const mv   = Math.min(room, srcCount|0);
      dst.count  = (dst.count|0) + mv;
      return (srcCount|0) - mv;
    }

    // split half (ceil) from slot, returning a NEW stack; mutates the original.
    function splitHalf(slot){
      if (isEmpty(slot)) return makeStack(null,0);
      const give = Math.ceil(slot.count / 2);
      slot.count -= give;
      const out = makeStack(slot.id, give, slot.nbt);
      if (slot.count <= 0){ slot.id = null; slot.nbt = null; }
      return out;
    }

    // swap stacks wholesale
    function swapStacks(a, b){
      const t = { id:a.id, count:a.count, nbt:a.nbt };
      a.id = b.id; a.count = b.count; a.nbt = b.nbt;
      b.id = t.id; b.count = t.count; b.nbt = t.nbt;
    }

    /* (optional) tiny pure helper used by quick-move later:
       try to merge into partials (same id), return leftover count.
       `slots` is an array of Slot-like {stack:{id,count}}.
    */
    function mergeIntoPartials(slots, incoming){
      if (isEmpty(incoming)) return 0;
      let left = incoming.count|0;
      for (const s of slots){
        if (left <= 0) break;
        if (!s || isEmpty(s.stack)) continue;
        if (!canStack(s.stack, incoming)) continue;
        left = mergeInto(s.stack, left);
      }
      return left;
    }

    /* (optional) put into first empty slots; returns leftover count. */
    function fillEmpties(slots, incoming){
      if (isEmpty(incoming)) return 0;
      let left = incoming.count|0;
      for (const s of slots){
        if (left <= 0) break;
        if (!s || !isEmpty(s.stack)) continue;
        // place fresh stack here (respect maxStack)
        const max = maxStackOf(incoming.id) ?? 64;
        const put = Math.min(max, left);
        s.stack = makeStack(incoming.id, put, incoming.nbt);
        left -= put;
      }
      return left;
    }
    // container-aware merge/fill that also notifies UI
    function mergeIntoPartialsIn(container, incoming){
      if (isEmpty(incoming)) return 0;
      let left = incoming.count|0;
      const changed = [];
      container._slots.forEach((s, i)=>{
        if (left<=0) return;
        if (isEmpty(s.stack)) return;
        if (!canStack(s.stack, incoming)) return;
        const before = s.stack.count|0;
        left = mergeInto(s.stack, left);     // mutates s.stack.count
        if ((s.stack.count|0) !== before) changed.push(i);
      });
      if (changed.length) container.notify(changed);
      return left;
    }

    function fillEmptiesIn(container, incoming){
      if (isEmpty(incoming)) return 0;
      let left = incoming.count|0;
      const changed = [];
      container._slots.forEach((s, i)=>{
        if (left<=0) return;
        if (!isEmpty(s.stack)) return;
        const max = maxStackOf(incoming.id) ?? 64;
        const put = Math.min(max, left);
        s.stack = makeStack(incoming.id, put, incoming.nbt);
        changed.push(i);
        left -= put;
      });
      if (changed.length) container.notify(changed);
      return left;
    }

    /* ===== STEP 3: Containers + Events (barebones) ===== */

    /* 3.1) Slot helper (uniform shape) */
    function makeEmptySlot(){ return { stack: makeStack(null,0) }; }

    /* 3.2) Tiny event emitter (no deps) */
    function makeEmitter(){
      const m = new Map();
      return {
        on(ev, fn){ (m.get(ev) || m.set(ev, new Set()).get(ev)).add(fn); return () => this.off(ev, fn); },
        off(ev, fn){ m.get(ev)?.delete(fn); },
        emit(ev, payload){ m.get(ev)?.forEach(fn=>fn(payload)); }
      };
    }

    /* 3.3) Array-backed Container */
    class ArrayContainer {
      constructor(size, name="container"){
        this._name = name;
        this._slots = Array.from({length:size}, makeEmptySlot);
        this.events = makeEmitter();  // emits: "slotsChanged", payload: indices[]
      }
      size(){ return this._slots.length; }
      get(i){ return this._slots[i]; }
      set(i, stack){
        const s = this._slots[i];
        if (!s) return;
        s.stack = isEmpty(stack) ? makeStack(null,0) : makeStack(stack.id, stack.count, stack.nbt);
        this.events.emit("slotsChanged", [i]);
      }
      /** mutate-friendly: call this when you changed counts inside a slot */
      touch(i){ this.events.emit("slotsChanged", [i]); }
    
      /** batch notify (for multiple indices at once) */
      notify(indices){ if (indices?.length) this.events.emit("slotsChanged", indices); }
    
      /** iterate */
      forEach(cb){ this._slots.forEach((s, i)=>cb(s, i)); }
    }

    /* 3.4) PlayerInventory (hotbar + backpack + selection) */
    class PlayerInventory {
      constructor(){
        this.hotbar   = new ArrayContainer(9,  "hotbar");
        this.backpack = new ArrayContainer(27, "backpack");
        this.selectedIndex = 0; // 0..8
      }
      getSelectedSlot(){ return this.hotbar.get(this.selectedIndex); }
      select(n){
        const clamped = Math.max(0, Math.min(8, n|0));
        if (clamped !== this.selectedIndex){
          this.selectedIndex = clamped;
          // UI can listen to this if needed
          this.onSelectChanged?.(this.selectedIndex);
        }
      }
      cycle(dir){ this.select((this.selectedIndex + (dir>0?1:-1) + 9) % 9); }
      addDrop(stack){
        if (!stack || !stack.id) return stack; // ignore bad drops
        let left = stack.count|0;     

        // 1) try merge into hotbar partials
        left = mergeIntoPartials(this.hotbar._slots, { id:stack.id, count:left, nbt:stack.nbt });
        if (left <= 0) return makeStack(null,0);      

        // 2) then backpack partials
        left = mergeIntoPartials(this.backpack._slots, { id:stack.id, count:left, nbt:stack.nbt });
        if (left <= 0) return makeStack(null,0);      

        // 3) fill empties in hotbar
        left = fillEmpties(this.hotbar._slots, { id:stack.id, count:left, nbt:stack.nbt });
        if (left <= 0) return makeStack(null,0);      

        // 4) fill empties in backpack
        left = fillEmpties(this.backpack._slots, { id:stack.id, count:left, nbt:stack.nbt });
        if (left <= 0) return makeStack(null,0);      

        return makeStack(stack.id, left, stack.nbt); // return leftover if inv full     
      }

    }

    



    const INV3 = new PlayerInventory();
    function buildHotbar(){
      const wrap = document.getElementById("hotbarSlots");
      wrap.innerHTML = "";
      for (let i=0;i<9;i++){
        const cell  = document.createElement("div"); cell.className = "hotCell";
        const icon  = document.createElement("div"); icon.className = "hotIcon";
        const count = document.createElement("div"); count.className = "hotCount";
        cell.appendChild(icon); cell.appendChild(count);
        wrap.appendChild(cell);
      }
    }

    function buildInventory(){ // simple 27-slot grid for later
      const grid = document.getElementById("invBackpack");
      grid.innerHTML = "";
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "repeat(9, 42px)";
      grid.style.gap = "6px";
      for (let i=0;i<27;i++){
        const cell = document.createElement("div");
        cell.className = "hotCell";               // reuse styles
        cell.dataset.key = `bag:${i}`;
        const icon  = document.createElement("div"); icon.className = "invIcon hotIcon";
        const count = document.createElement("div"); count.className = "invCount hotCount";
        cell.appendChild(icon); cell.appendChild(count);
        grid.appendChild(cell);
      }
      grid.style.display = "none"; // keep hidden for now
    }

    /* ===== STEP 4: Cursor + L-click (pick/merge/swap) ===== */

    // 4.1) Cursor state
    const Cursor = { stack: makeStack(null,0) };
    const CursorEl = document.getElementById("invCursor");
    function cursorIsEmpty(){ return isEmpty(Cursor.stack); }

    // 4.2) Paint cursor ghost
    function paintCursor(){
      if (cursorIsEmpty()){ CursorEl.style.display = "none"; return; }
      const icon = CursorEl.querySelector(".hotIcon");
      const cnt  = CursorEl.querySelector(".hotCount");
      setIconBG(icon, blockNumFromItemId(Cursor.stack.id));
      cnt.textContent = (Cursor.stack.count > 1) ? String(Cursor.stack.count) : "";
      CursorEl.style.display = "block";
    }

    // follow mouse
    addEventListener("mousemove", (e)=>{
      if (CursorEl.style.display !== "none"){
        CursorEl.style.left = e.clientX + "px";
        CursorEl.style.top  = e.clientY + "px";
      }
    });

    // 4.3) Slot resolver: which container/index did we click?
    function resolveSlotFromCell(cell){
      if (!cell) return null;
    
      // hotbar
      const hotWrap = document.getElementById("hotbarSlots");
      if (hotWrap && hotWrap.contains(cell)){
        // index by DOM order
        const kids = [...hotWrap.children];
        const idx = kids.indexOf(cell);
        if (idx >= 0) return { container: INV3.hotbar, index: idx };
      }
    
      // backpack (expects data-key="bag:i")
      if (cell.dataset && cell.dataset.key && cell.dataset.key.startsWith("bag:")){
        const i = parseInt(cell.dataset.key.slice(4), 10);
        return { container: INV3.backpack, index: i };
      }
    
      return null;
    }

    // 4.4) Core L-click behavior (Minecraft-style)
    function handleLeftClickSlot(cell){
      const res = resolveSlotFromCell(cell);
      if (!res) return;
      const cont = res.container;
      const i    = res.index;
      const slot = cont.get(i); if (!slot) return;
    
      // both stacks we'll work with
      const S = slot.stack;
      const C = Cursor.stack;
    
      if (cursorIsEmpty()){
        // pick up entire slot
        if (isEmpty(S)) return; // nothing to pick
        Cursor.stack = makeStack(S.id, S.count, S.nbt);
        // clear slot
        cont.set(i, makeStack(null,0));
        paintCursor();
        return;
      }
    
      // cursor has something
      if (isEmpty(S)){
        // place as much as possible into empty slot
        const max = maxStackOf(C.id) ?? 64;
        const put = Math.min(max, C.count|0);
        cont.set(i, makeStack(C.id, put, C.nbt));
        Cursor.stack.count -= put;
        if (Cursor.stack.count <= 0) Cursor.stack = makeStack(null,0);
        paintCursor();
        return;
      }
    
      // both have items
      if (canStack(S, C)){
        // merge cursor into slot (respect max stack)
        const left = mergeInto(S, C.count|0);
        // we mutated slot.count directly; notify UI
        cont.touch(i);
        Cursor.stack.count = left;
        if (Cursor.stack.count <= 0) Cursor.stack = makeStack(null,0);
        paintCursor();
        return;
      }
    
      // different items → swap
      const tmp = makeStack(S.id, S.count, S.nbt);
      cont.set(i, makeStack(C.id, C.count, C.nbt));
      Cursor.stack = tmp;
      paintCursor();
    }

    // 4.5) Attach listeners (L-click only for now)
    // hotbar
    document.getElementById("hotbarSlots").addEventListener("click", (e)=>{
      const cell = e.target.closest(".hotCell");
      if (!cell) return;
      e.stopPropagation();
    
      if (e.shiftKey){
        // hotbar -> backpack
        const idx = [...cell.parentElement.children].indexOf(cell);
        quickMove(INV3.hotbar, idx, [INV3.backpack]);
        return;
      }
    
      // normal L-click pick/merge/swap
      handleLeftClickSlot(cell);
    });

    // backpack
    document.getElementById("invBackpack").addEventListener("click", (e)=>{
      const cell = e.target.closest("[data-key]");
      if (!cell) return;
      e.stopPropagation();
    
      if (e.shiftKey){
        // backpack -> hotbar
        const idx = parseInt(cell.dataset.key.slice(4), 10);
        quickMove(INV3.backpack, idx, [INV3.hotbar]);
        return;
      }
    
      // normal L-click pick/merge/swap
      handleLeftClickSlot(cell);
    });

//STEP FIVE//
    let invOpen = false;

    function openInventory(){
      invOpen = true;
      document.getElementById("invPanel").style.display = "grid";
      document.getElementById("invBackpack").style.display = "grid"; // <-- add this
      // show cursor: exit pointer lock if active
      if (document.pointerLockElement) document.exitPointerLock();
    }

    function closeInventory(){
      invOpen = false;
      document.getElementById("invPanel").style.display = "none";
      document.getElementById("invBackpack").style.display = "none"; // <-- add this
    }

    addEventListener("keydown", (e)=>{
      if (e.key.toLowerCase() === "e"){
        e.preventDefault();
        invOpen ? closeInventory() : openInventory();
      }
      if (e.key === "Escape" && invOpen){
        e.preventDefault();
        closeInventory();
      }
    });

    // while inventory is open, ignore movement input
    function movementEnabled(){ return !invOpen && pointerLocked; }


    function repaintHotbar(){
      const icons  = document.querySelectorAll("#hotbarSlots .hotIcon");
      const counts = document.querySelectorAll("#hotbarSlots .hotCount");
      for (let i=0; i<9; i++){
        const icon = icons[i], lbl = counts[i];
        const st = INV3.hotbar.get(i)?.stack;
        if (!icon || !lbl) continue;
        if (!st || !st.id || st.count<=0){
          icon.style.visibility = "hidden";
          lbl.textContent = "";
        } else {
          icon.style.visibility = "visible";
          setIconBG(icon, blockNumFromItemId(st.id));
          lbl.textContent = (st.count>1) ? String(st.count) : "";
        }
      }
    }

    function repaintBackpack(){
      for (let i=0; i<27; i++){
        const cell = document.querySelector(`#invBackpack [data-key="bag:${i}"]`);
        if (!cell) continue;
        const icon = cell.querySelector(".invIcon");
        const lbl  = cell.querySelector(".invCount");
        const st   = INV3.backpack.get(i)?.stack;
        if (!st || !st.id || st.count<=0){
          icon.style.visibility = "hidden";
          lbl.textContent = "";
        } else {
          icon.style.visibility = "visible";
          setIconBG(icon, blockNumFromItemId(st.id));
          lbl.textContent = (st.count>1) ? String(st.count) : "";
        }
      }
    }
    //STEP SIX???//
    function quickMove(containerFrom, indexFrom, targetContainers){
      const slot = containerFrom.get(indexFrom); if (!slot) return;
    
      // nothing to move
      if (!slot.stack || !slot.stack.id || slot.stack.count <= 0) return;
    
      // take a working copy of what's in the slot
      let moving = makeStack(slot.stack.id, slot.stack.count, slot.stack.nbt);
    
      // 1) merge into partials across targets (order matters)
      for (const cont of targetContainers){
        moving.count = mergeIntoPartialsIn(cont, moving);
        if (moving.count <= 0) break;
      }
      // 2) fill empties across targets
      if (moving.count > 0){
        for (const cont of targetContainers){
          moving.count = fillEmptiesIn(cont, moving);
          if (moving.count <= 0) break;
        }
      }
    
      // update the source slot with leftover (or clear)
      if (moving.count !== slot.stack.count){
        const left = moving.count|0;
        if (left > 0){
          slot.stack.count = left; // same item, reduced count
          containerFrom.touch(indexFrom);
        } else {
          containerFrom.set(indexFrom, makeStack(null,0));
        }
      }
    }

    // expose for quick testing
    window.repaintHotbar   = repaintHotbar;
    window.repaintBackpack = repaintBackpack;
    window.ArrayContainer   = ArrayContainer;
    window.PlayerInventory  = PlayerInventory;
    window.INV3             = INV3;
    window.makeStack          = makeStack;
    window.isEmpty            = isEmpty;
    window.spaceLeft          = spaceLeft;
    window.canStack           = canStack;
    window.takeFrom           = takeFrom;
    window.mergeInto          = mergeInto;
    window.splitHalf          = splitHalf;
    window.swapStacks         = swapStacks;
    window.mergeIntoPartials  = mergeIntoPartials;
    window.fillEmpties        = fillEmpties;
    window.itemIdFromBlockId = itemIdFromBlockId;
    window.maxStackOf        = maxStackOf;
    window.canStackTogether  = canStackTogether;
    window.BLOCK             = BLOCK;
    /* ===== Day–Night ===== */
    let dayTime = 0;                 // 0..1 (fraction of day)
    const DAY_SECONDS   = 5*60;        // full day length (tweak)
    const SUN_MIN_ELEV  = -75;        // degrees (sun below horizon at night)
    const SUN_MAX_ELEV  = 75;        // degrees (noon height)

    function updateSun(dt){
      // progress the day
      dayTime = (dayTime + dt / DAY_SECONDS) % 1;
    
      // phase 0..2π
      const phase = dayTime * Math.PI * 2;
    
      // elevation swings smoothly from MIN..MAX (sin curve mapped to range)
      const mid   = (SUN_MAX_ELEV + SUN_MIN_ELEV) * 0.5;
      const amp   = (SUN_MAX_ELEV - SUN_MIN_ELEV) * 0.5;
      const elev  = mid + Math.sin(phase) * amp;
    
      // azimuth spins all day (0..360). Shift if you want sunrise from east.
      const az    = (dayTime * 360); // add +180 if you want opposite
    
      setSun(elev, az);
    
      // daylight factor 0..1 based on elevation above horizon
      const lightT = Math.max(0, Math.min(1, (elev - 0) / (SUN_MAX_ELEV - 0)));
    
      // lights: dim to night
      amb.intensity = 0.06 + 0.22 * lightT;   // 0.06..0.28
      dir.intensity = 0.00 + 0.80 * lightT;   // 0..0.8
      // blue wash at night
      nightLight.intensity = (1 - lightT) * 0.3; // stronger at night, 0 at noon

      // optional: disable shadows at night (perf)
      if (typeof renderer.shadowMap !== "undefined"){
        const wantShadows = lightT > 0.05;
        if (renderer.shadowMap.enabled !== wantShadows){
          renderer.shadowMap.enabled = wantShadows;
          if (typeof sunLight !== "undefined") sunLight.castShadow = wantShadows;
        }
      }
    
      // sky/fog palette
      const dayCol   = new THREE.Color(0xcfe8ff); // day blue
      const duskCol  = new THREE.Color(0x8b5ea7); // purple dusk
      const nightCol = new THREE.Color(0x0b1220); // deep night
    
      // blend: night→dusk→day using lightT (with a soft knee)
      const duskT = Math.min(1, Math.max(0, (elev + 6) / 16)); // around -6°..10°
      const skyT  = lightT*lightT; // softer rise
    
      const fogMix1 = nightCol.clone().lerp(duskCol, duskT);
      const fogMix2 = fogMix1.clone().lerp(dayCol,  skyT);
      scene.fog.color.copy(fogMix2);
    }
    // Hide F3 HUD on boot
    addEventListener("DOMContentLoaded", ()=>{
      const hud = document.getElementById("hud");
      if (hud) hud.style.display = "none";
    });
    addEventListener("DOMContentLoaded", ()=>{
      const box = document.getElementById("betterFps");
      if (box){
        box.checked = true;           // show it as enabled
        applyBetterFps(true);         // actually apply the preset
      }
    });

    // 4x4 atlas icon picker for the hotbar (tile coords)
    function iconTileFor(blockId){
      // match your UV_TILES setup
      if (blockId === BLOCK.STONE)  return { tx:0, ty:0 };
      if (blockId === BLOCK.GRASS)  return { tx:2, ty:0 }; // use top face for icon
      if (blockId === BLOCK.DIRT)   return { tx:1, ty:0 };
      if (blockId === BLOCK.GLASS)  return { tx:0, ty:1 };
      if (blockId === BLOCK.LOG)    return { tx:1, ty:1 };
      if (blockId === BLOCK.LEAVES) return { tx:2, ty:1 };
      return { tx:0, ty:0 };
    }

    /* Icon % mapping reused */
    function setIconBG(div, blockId){
      const {tx,ty} = iconTileFor(blockId ?? BLOCK.STONE);
      const uStep = 100 / (4-1), vStep = 100 / (4-1);
      div.style.backgroundPosition = `${tx*uStep}% ${ty*vStep}%`;
    }

    // Toggle with F3
    addEventListener("keydown", (e)=>{
      if (e.key === "F3"){
        const hud = document.getElementById("hud");
        if (hud){
          hud.style.display = (hud.style.display === "none" ? "block" : "none");
          e.preventDefault();
        }
      }
    });

    /* ===== Scene ===== */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 3000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);
    // Enable shadows globally
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // nice soft shadows

//sky
    // Sky dome
    const sky = new Sky();
    sky.scale.setScalar(450000);
    scene.add(sky);

    // Render sky behind everything (don’t touch depth)
    sky.material.depthWrite = false;
    sky.material.depthTest  = false;
    sky.renderOrder = -1;

    // Sky uniforms
    const skyUniforms = sky.material.uniforms;
    skyUniforms.turbidity.value = 10;
    skyUniforms.rayleigh.value = 2;
    skyUniforms.mieCoefficient.value = 0.005;
    skyUniforms.mieDirectionalG.value = 3;

    // --- Sun (directional light with shadows) ---
    const sunLight = new THREE.DirectionalLight(0xffe9a9, 0.8); // warm pale yellow
    sunLight.castShadow = true;
    const nightLight = new THREE.AmbientLight(0x223355, 0.0); // start at 0 intensity
    scene.add(sunLight);
    scene.add(nightLight);

    // Shadow quality / coverage
    sunLight.shadow.mapSize.set(512, 512);   // 1024..4096; higher = sharper, slower
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far  = 1500;
    // Shadow camera bounds (large square over world)
    const SHADOW_RADIUS = 150;
    sunLight.shadow.camera.left   = -SHADOW_RADIUS;
    sunLight.shadow.camera.right  =  SHADOW_RADIUS;
    sunLight.shadow.camera.top    =  SHADOW_RADIUS;
    sunLight.shadow.camera.bottom = -SHADOW_RADIUS;
    // Acne tweaks
    sunLight.shadow.bias = -0.00025;
    sunLight.shadow.normalBias = 0.35;

    // Target (light looks at this object)
    const sunTarget = new THREE.Object3D();
    scene.add(sunTarget);
    sunLight.target = sunTarget;

    // Sun position helper (keeps sky + light in sync)
    const sun = new THREE.Vector3();
    function setSun(elevationDeg = 45, azimuthDeg = 180) {
      const phi = THREE.MathUtils.degToRad(90 - elevationDeg); // elevation
      const theta = THREE.MathUtils.degToRad(azimuthDeg);      // azimuth
      sun.setFromSphericalCoords(1, phi, theta);
    
      // update sky
      skyUniforms.sunPosition.value.copy(sun);
    
      // place directional light far in the sun direction
      const sunDir = sun.clone().normalize();
      sunLight.position.copy(sunDir).multiplyScalar(800);
    
      // look at world origin (or move target to your player if you prefer)
      sunTarget.position.set(0, 0, 0);
      sunLight.target.updateMatrixWorld();
    }
    setSun(45, 180); // midday by default
//sky
    const EPS_PLACEMENT = 1e-3; // small gap so touching faces are allowed

    function playerAABB() {
      const half = player.size.clone().multiplyScalar(0.5);
      return {
        min: player.pos.clone().sub(half),
        max: player.pos.clone().add(half),
      };
    }

    function blockAABB(x, y, z) {
      return {
        min: new THREE.Vector3(x, y, z),
        max: new THREE.Vector3(x + 1, y + 1, z + 1),
      };
    }

    function aabbOverlap(a, b, eps = 0) {
      // strict overlap check (not counting just-touching faces as overlap)
      return (
        a.min.x < b.max.x - eps && a.max.x > b.min.x + eps &&
        a.min.y < b.max.y - eps && a.max.y > b.min.y + eps &&
        a.min.z < b.max.z - eps && a.max.z > b.min.z + eps
      );
    }
    // Seeded RNG
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    // --- Chunk array helpers (no methods on chunk needed) ---
    function cIdx(x,y,z){ return x + CHUNK.X*(z + CHUNK.Z*y); }
      
    function cGet(c, x,y,z){
      if (x<0||x>=CHUNK.X||y<0||y>=CHUNK.Y||z<0||z>=CHUNK.Z) return BLOCK.AIR;
      return c.blocks[cIdx(x,y,z)];
    }
    function cSet(c, x,y,z, v){
      if (x<0||x>=CHUNK.X||y<0||y>=CHUNK.Y||z<0||z>=CHUNK.Z) return;
      c.blocks[cIdx(x,y,z)] = v;
    }
    
    function wouldCollideWithPlayer(x, y, z) {
      const pa = playerAABB();
      const ba = blockAABB(x, y, z);
      return aabbOverlap(pa, ba, EPS_PLACEMENT);
    }
    scene.fog = new THREE.Fog(0x87CEEB, 80, 600);

    // Lights
    scene.add(new THREE.HemisphereLight(0xcfe8ff, 0x7aa0b8, 0.85));
    const amb = new THREE.AmbientLight(0xffffff, 0.15); // 10–20% is enough
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.7,1,0.4); scene.add(dir);

    const info = document.getElementById("info");
    // === Hearts HUD (MC-style, above hotbar) ===
    const heartsHUD = document.createElement("div");
    heartsHUD.id = "heartsHUD";
    Object.assign(heartsHUD.style, {
      position: "fixed",
      left: "50%",
      transform: "translateX(-50%)",
      bottom: "96px",                 // temp; we’ll auto-calc below
      fontSize: "22px",
      letterSpacing: "2px",
      lineHeight: "1",
      color: "#ff4d4d",
      textShadow: "0 2px 0 #000, 0 0 6px rgba(0,0,0,.4)",
      pointerEvents: "none",
      userSelect: "none",
      zIndex: "9999"
    });
    document.body.appendChild(heartsHUD);

    // auto-position just above the hotbar, if #hotbar exists
    function positionHearts(){
      const hb = document.getElementById("hotbar");
      if (hb){
        const r = hb.getBoundingClientRect();
        const pxFromBottom = window.innerHeight - r.top;
        heartsHUD.style.bottom = (pxFromBottom + 6) + "px"; // 6px gap above bar
      } else {
        heartsHUD.style.bottom = "96px"; // fallback
      }
    }
    addEventListener("resize", positionHearts);
    setTimeout(positionHearts, 0);
    const foodEl = document.getElementById("food") || document.getElementById("stats"); // whichever you used
    if (foodEl) foodEl.style.display = "none";

    // === Survival v0.1 ===
    const STATS = {
      hpMax: 20, hp: 20,          // 10 hearts = 20 hp
      foodMax: 20, food: 20,      // 10 drumsticks = 20
      satur: 5,                   // simple “buffer” for hunger ticks
      invuln: 0                   // post-hit i-frames (seconds)
    };

    const statsLine = document.createElement("div");
    statsLine.id = "stats";
    statsLine.style.marginTop = "6px";
    document.getElementById("hud").appendChild(statsLine);

    function paintStats(){
      // draw hearts only (every 2 hp = 1 heart)
      let hearts = "";
      for (let i = 0; i < STATS.hpMax; i += 2){
        hearts += (STATS.hp >= i + 2) ? "❤" : "♡";
      }
      heartsHUD.textContent = hearts;
      // keep hunger logic running silently (no UI)
    }




    const atlas = new THREE.TextureLoader().load("atlas.png",
      () => console.log("[atlas] loaded", atlas.image?.width, "x", atlas.image?.height),
      undefined,
      (err) => console.error("[atlas] FAILED to load", err)
    );
    atlas.flipY = false;
    atlas.magFilter = THREE.NearestFilter;
    atlas.minFilter = THREE.NearestFilter; // simple & safe
    atlas.wrapS = THREE.ClampToEdgeWrapping;
    atlas.wrapT = THREE.ClampToEdgeWrapping;
    if (atlas.colorSpace !== undefined) atlas.colorSpace = THREE.SRGBColorSpace;

    let CHUNK_MAT = new THREE.MeshLambertMaterial({ map: atlas, fog: true });

    // Tiles (4x4 atlas)
    const TILES_X = 4, TILES_Y = 4;
    function tileUV(tx, ty){
      const su = 1 / TILES_X, sv = 1 / TILES_Y;
      // tiny inset to avoid bleeding
      const safeW = (atlas.image?.width  || 128);
      const safeH = (atlas.image?.height || 128);
      const insetU = 0.5 / safeW;
      const insetV = 0.5 / safeH;
      const u0 = tx*su + insetU, v0 = ty*sv + insetV;
      const u1 = (tx+1)*su - insetU, v1 = (ty+1)*sv - insetV;
      return { u0, v0, u1, v1 };
    }
    const UV_TILES = {
      STONE:      tileUV(0,0),
      GRASS_TOP:  tileUV(2,0),
      GRASS_SIDE: tileUV(3,0),
      DIRT:       tileUV(1,0),
      GLASS:      tileUV(0,1),
      LOG:        tileUV(1,1),
      LEAVES:     tileUV(2,1)
    };
    function uvFor(blockId, faceDir){
      if (blockId === BLOCK.STONE) return UV_TILES.STONE;
      if (blockId === BLOCK.DIRT)  return UV_TILES.DIRT;
      if (blockId === BLOCK.GLASS) return UV_TILES.GLASS;
      if (blockId === BLOCK.GRASS){
        if (faceDir === 2) return UV_TILES.GRASS_TOP;  // +Y
        if (faceDir === 3) return UV_TILES.DIRT;       // -Y
        return UV_TILES.GRASS_SIDE;                    // sides
      }
      if (blockId === BLOCK.LOG) return UV_TILES.LOG;
      if (blockId === BLOCK.LEAVES) return UV_TILES.LEAVES;
      return UV_TILES.STONE;
    }

    /* ===== Better FPS mode ===== */
    const Perf = { saved:null };

    function setShadows(enabled){
      renderer.shadowMap.enabled = enabled;
      if (typeof sunLight !== "undefined") sunLight.castShadow = enabled;
    }

    function setPixelScale(low){
      const target = low ? Math.max(0.6, devicePixelRatio*0.65) : devicePixelRatio;
      renderer.setPixelRatio(target);
      renderer.setSize(innerWidth, innerHeight);
    }

    function applyBetterFps(on){
      if (on && !Perf.saved){
        // save current
        Perf.saved = {
          GRID_RADIUS, BUILDS_PER_FRAME,
          pixel: renderer.getPixelRatio ? renderer.getPixelRatio() : devicePixelRatio,
          shadows: renderer.shadowMap.enabled
        };
      
        GRID_RADIUS = Math.min(GRID_RADIUS, 4);
        BUILDS_PER_FRAME = Math.min(BUILDS_PER_FRAME, 4);
        setShadows(false);
        setPixelScale(true);
        scheduleGridRefresh();
      
      } else if (!on && Perf.saved){
        // restore
        GRID_RADIUS       = Perf.saved.GRID_RADIUS;
        BUILDS_PER_FRAME  = Perf.saved.BUILDS_PER_FRAME;
        setShadows(Perf.saved.shadows);
        renderer.setPixelRatio(Perf.saved.pixel);
        renderer.setSize(innerWidth, innerHeight);
        Perf.saved = null;
        scheduleGridRefresh();
      }
    }

    /* hook up checkbox */
    addEventListener("DOMContentLoaded", () => {
      const box = document.getElementById("betterFps");
      if (!box) return;
      box.addEventListener("change", e => applyBetterFps(e.target.checked));
    });

    /* ===== Input ===== */
    const keys = new Set();
    let pointerLocked = false;
    let yaw = 0, pitch = 0;
    let hudVisible = true;
    addEventListener("keydown", (e)=>{
      if (e.key === "Shift") isCrouch = true;
      if (e.key.toLowerCase() === "z") isRun = true;
    });
    addEventListener("keyup", (e)=>{
      if (e.key === "Shift") isCrouch = false;
      if (e.key.toLowerCase() === "z") isRun = false;
    });

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
    addEventListener("keydown", (e)=>{
      if (e.key.toLowerCase() === "f" && !pointerLocked && !invOpen){
        renderer.domElement.requestPointerLock();
      }
    });
    // stop clicks inside inventory from bubbling
    document.getElementById("invPanel").addEventListener("mousedown", e=> e.stopPropagation());
    document.getElementById("hotbarSlots").addEventListener("mousedown", e=> e.stopPropagation());
    
    document.addEventListener("pointerlockchange", () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
    });
    document.addEventListener("mousemove", (e) => {
      if (!pointerLocked) return;
      const sens = 0.0025, MAX_D = 80;
      const dx = Math.max(-MAX_D, Math.min(MAX_D, e.movementX||0));
      const dy = Math.max(-MAX_D, Math.min(MAX_D, e.movementY||0));
      yaw   -= dx * sens;
      pitch -= dy * sens;
      pitch = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001, pitch));
    });
    addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys.add(k);

      if (k === "f3") {
        hudVisible = !hudVisible;
        document.getElementById("hud").style.display = hudVisible ? "block" : "none";
        e.preventDefault(); e.stopPropagation();
        return;
      }
      if (k === "e"){
        e.preventDefault();
        return;
      }
      if (k==="r") regenAll();
    });
    addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
    addEventListener("contextmenu", (e) => e.preventDefault());

    /* ===== Slider bindings ===== */
    const bind = (id, setter, fmt=(v)=>v)=> {
      const el = document.getElementById(id);
      const out = document.getElementById(id.replace("Slider","Val"));
      const sync = ()=> { if(out) out.textContent = fmt(el.value); };
      el.addEventListener("input", (e)=>{ setter(parseFloat(e.target.value)); regenAll(); sync(); });
      sync();
    };
    bind("gSlider",   v => GRAVITY=v);
    bind("jSlider",   v => JUMP_VEL=v);
    bind("wSlider",   v => WALK=v);
    bind("rSlider",   v => { GRID_RADIUS = v|0; scheduleGridRefresh(); }, v=>v|0);
    bind("bSlider",   v => { BUILDS_PER_FRAME = v|0; }, v=>v|0);

    /* ===== Noise ===== */
    function hash2i(x, y, seed=WORLD_SEED) {
      let h = x*374761393 + y*668265263 + seed*1447;
      h = (h ^ (h>>13)) * 1274126177;
      return (h>>>0)/0xffffffff;
    }
    const smoothstep = t => t*t*(3-2*t);
    function valueNoise2(x,y){
      const xi=Math.floor(x), yi=Math.floor(y);
      const tx=x-xi, ty=y-yi;
      const a=hash2i(xi,yi), b=hash2i(xi+1,yi), c=hash2i(xi,yi+1), d=hash2i(xi+1,yi+1);
      const sx=smoothstep(tx), sy=smoothstep(ty);
      const u=a+(b-a)*sx, v=c+(d-c)*sx;
      return u+(v-u)*sy;
    }
    function fbm2(x,y){
      let amp=1,freq=1,sum=0,norm=0;
      for(let i=0;i<4;i++){
        sum+=valueNoise2(x*freq,y*freq)*amp;
        norm+=amp; amp*=0.5; freq*=2;
      }
      return sum/norm;
    }
    function ridged(x, y, octaves=4){
      let amp=1, freq=1, sum=0, norm=0;
      for(let i=0;i<octaves;i++){
        const r = 1.0 - Math.abs(0.5 - fbm2(x*freq, y*freq)) * 2.0;
        sum += r * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm;
    }
    function warp2(x, y){
      const wx = fbm2(x*WARP_SCALE*2.13, y*WARP_SCALE*0.91);
      const wy = fbm2(x*WARP_SCALE*1.31, y*WARP_SCALE*1.73);
      return { x: x + (wx-0.5)*2*WARP_STRENGTH, y: y + (wy-0.5)*2*WARP_STRENGTH };
    }
    function sstep(a,b,t){ const u=Math.max(0,Math.min(1,(t-a)/(b-a))); return u*u*(3-2*u); }
    function sampleTerrain(wx, wz) {
      const w = warp2(wx, wz); const x = w.x, y = w.y;
      const biomeN = fbm2(x*BIOME_SCALE, y*BIOME_SCALE);
      const tPlains    = sstep(0.00, 0.35, biomeN);
      const tHills     = sstep(0.30, 0.65, biomeN);
      const tMountains = sstep(0.55, 0.95, biomeN);
      const wSum = tPlains + tHills + tMountains + 1e-6;
      const bP = tPlains/wSum, bH=tHills/wSum, bM=tMountains/wSum;
      const plains = PLAINS_BASE + (fbm2(x*0.03, y*0.03)-0.5)*2*PLAINS_WOBBLE;
      const hills  = PLAINS_BASE + 3 + fbm2(x*HILLS_SCALE, y*HILLS_SCALE)*HILLS_AMP;
      const mountains = PLAINS_BASE + 6 + ridged(x*MOUNT_SCALE, y*MOUNT_SCALE)*MOUNT_RIDGES;
      let h = bP*plains + bH*hills + bM*mountains;
      const spot = fbm2(x*SPOT_SCALE, y*SPOT_SCALE);
      if (spot > SPOT_THRESHOLD){
        const k = (spot - SPOT_THRESHOLD) / (1 - SPOT_THRESHOLD);
        const spotWeight = bP*1.0 + bH*0.6;
        h += k * SPOT_AMPLITUDE * spotWeight;
      }
      return Math.floor(h);
    }
    function surfaceYAt(wx, wz){
      // ground height from your terrain sampler (clamped to world)
      const hRaw = FLAT_WORLD_Y ?? sampleTerrain(wx, wz);
      return Math.max(1, Math.min(CHUNK.Y - 2, hRaw));
    }


    const FLAT_WORLD_Y = null;

    /* ===== World ===== */
    class Chunk {
      constructor(cx,cz){
        this.cx=cx; this.cz=cz;
        this.blocks=new Uint8Array(CHUNK.X*CHUNK.Y*CHUNK.Z);
        this.mesh=null;
        this.generated=false;
        this.dirty=false;
      }
    }
    const chunks = new Map();
    window.chunks = chunks; // optional debug
    const buildQueue = [];
    const key = (cx,cz)=>`${cx},${cz}`;
    const idx = (x,y,z)=> x + CHUNK.X*(z + CHUNK.Z*y);

    function generateChunk(c){
      if (c.generated) return;
      const baseX = c.cx * CHUNK.X, baseZ = c.cz * CHUNK.Z;
    
      for (let z = 0; z < CHUNK.Z; z++){
        for (let x = 0; x < CHUNK.X; x++){
          const wx = baseX + x, wz = baseZ + z;
          const hRaw = (typeof FLAT_WORLD_Y !== "undefined" && FLAT_WORLD_Y !== null) ? FLAT_WORLD_Y : sampleTerrain(wx, wz);
          const h = Math.max(1, Math.min(CHUNK.Y - 2, hRaw));
        
          for (let y = 0; y < CHUNK.Y; y++){
            let id = BLOCK.AIR;
          
            if (y <= h){
              // don’t let caves break the top block or the 1st dirt layer
              const allowCave = (y <= h - 2) && sampleCave(wx, y, wz);
            
              if (allowCave){
                id = BLOCK.AIR;                               // carve cave
              } else if (y === h){
                id = BLOCK.GRASS;                             // surface
              } else if (y < h - 3){
                id = BLOCK.STONE;                             // deep
              } else {
                id = BLOCK.DIRT;                              // just under grass
              }
            }
          
            c.blocks[idx(x, y, z)] = id;
          }
        }
      }
      carveWormsInChunk(c, 3);  // 0–5 works; higher = more tunnels
      // decorate this chunk with trees (unchanged)
      decorateChunkTrees(c, WORLD_SEED, fbm2);
      c.generated = true;
      c.dirty = true;
      enqueueBuild(c);
      markNeighborsDirty(c.cx, c.cz);
    }


    function shouldDrawFace(cur, neighbor){
      if (neighbor === BLOCK.AIR) return true;
      if (neighbor === BLOCK.GLASS && cur !== BLOCK.GLASS) return true;
      return false;
    }

    function neighborBlock(c,x,y,z,dir){
      let nx=x,ny=y,nz=z,cx=c.cx,cz=c.cz;
      if(dir===0)nx++; if(dir===1)nx--;
      if(dir===2)ny++; if(dir===3)ny--;
      if(dir===4)nz++; if(dir===5)nz--;
      if(ny<0||ny>=CHUNK.Y) return BLOCK.AIR;
      if(nx<0){cx--;nx+=CHUNK.X;}
      if(nx>=CHUNK.X){cx++;nx-=CHUNK.X;}
      if(nz<0){cz--;nz+=CHUNK.Z;}
      if(nz>=CHUNK.Z){cz++;nz-=CHUNK.Z;}
      const nc=chunks.get(key(cx,cz));
      if(!nc||!nc.generated) return BLOCK.AIR;
      return nc.blocks[idx(nx,ny,nz)];
    }
    // Biome-aware trees using fbm2 that returns 0..1
    function decorateChunkTrees(chunk, worldSeed, noise2D){
      const { cx, cz } = chunk;
      const wx0 = cx * CHUNK.X, wz0 = cz * CHUNK.Z;
    
      // per-chunk RNG
      const rng = mulberry32((worldSeed ^ (cx*73856093) ^ (cz*19349663)) >>> 0);
    
      // ---- 1) Biome mask (low frequency, big regions) ----
      const BIOME_SCALE = 0.005;              // smaller => bigger regions
      let biome01 = noise2D(wx0 * BIOME_SCALE, wz0 * BIOME_SCALE); // 0..1
      if (!Number.isFinite(biome01)) biome01 = 0.5;
    
      // classify
      let targetTrees;     // how many trees to try in this chunk
      let densThreshold;   // column acceptance threshold (0..1)
      let sampleProb;      // how many columns we even test
    
      if (biome01 > 0.62) {               // FOREST
        targetTrees   = 10 + Math.floor(biome01 * 6); // 10..16
        densThreshold = 0.45;                          // permissive
        sampleProb    = 0.45;                          // scan many columns
      } else if (biome01 < 0.38) {        // PLAINS
        // ≈ 1 chunk out of 4 gets a single tree
        const gate = (((cx*92837111) ^ (cz*689287499) ^ worldSeed) & 3) === 0;
        targetTrees   = gate ? 1 : 0;
        densThreshold = 0.85;
        sampleProb    = gate ? 0.15 : 0.0;
      } else {                            // TRANSITION
        targetTrees   = 3;
        densThreshold = 0.65;
        sampleProb    = 0.25;
      }
      if (targetTrees <= 0 || sampleProb <= 0) return;
    
      // ---- 2) Scan positions strictly inside this chunk ----
      const pad = 2;
      let placed = 0;
    
      // slight random offsets to avoid grid look
      const sx = pad + Math.floor(rng()*3);
      const sz = pad + Math.floor(rng()*3);
    
      for (let lz = sz; lz < CHUNK.Z - pad && placed < targetTrees; lz++){
        for (let lx = sx; lx < CHUNK.X - pad && placed < targetTrees; lx++){
          if (rng() > sampleProb) continue;
        
          const wx = wx0 + lx, wz = wz0 + lz;
        
          // local density noise (higher freq than biome), 0..1
          let dens01 = noise2D(wx * 0.02, wz * 0.02);
          if (!Number.isFinite(dens01)) dens01 = 0.5;
          if (dens01 < densThreshold) continue;
        
          // find top
          let yTop = -1;
          for (let y = CHUNK.Y-2; y >= 1; y--){
            if (cGet(chunk, lx, y, lz) !== BLOCK.AIR){ yTop = y; break; }
          }
          if (yTop < 0) continue;
        
          // must be grass surface with air above
          if (cGet(chunk, lx, yTop,   lz) !== BLOCK.GRASS) continue;
          if (cGet(chunk, lx, yTop+1, lz) !== BLOCK.AIR)   continue;
        
          // gentle slope check within this chunk
          const topIn = (qx,qz)=>{
            if (qx<0||qx>=CHUNK.X||qz<0||qz>=CHUNK.Z) return yTop;
            for (let yy=CHUNK.Y-2; yy>=1; yy--) if (cGet(chunk,qx,yy,qz)!==BLOCK.AIR) return yy;
            return yTop;
          };
          const a = topIn(lx-1,lz), b = topIn(lx+1,lz), c = topIn(lx,lz-1), d = topIn(lx,lz+1);
          if (Math.max(a,b,c,d) - Math.min(a,b,c,d) > 2) continue;
        
          // place tree (local-only; uses cSet/cGet)
          placeTreeLocal(chunk, lx, yTop+1, lz, rng);
          placed++;
        }
      }
    }

    // Place ONE tree strictly inside this chunk (no cross-border writes)
    function placeTreeLocal(chunk, lx, y, lz, rng){
      const LOG = BLOCK.LOG ?? 5;
      const LEAVES = BLOCK.LEAVES ?? 6;
    
      const h = 4 + Math.floor(rng()*3); // trunk 4..6
    
      // trunk
      for (let i=0; i<h; i++){
        const yy = y + i;
        if (yy<=0 || yy>=CHUNK.Y) break;
        cSet(chunk, lx, yy, lz, LOG);
      }
    
      // canopy
      const topY = y + h - 1;
      const R = 2;
      for (let dx=-R; dx<=R; dx++){
        for (let dy=-R; dy<=R; dy++){
          for (let dz=-R; dz<=R; dz++){
            const ax = lx+dx, ay = topY+dy, az = lz+dz;
            if (ax<0||ax>=CHUNK.X||az<0||az>=CHUNK.Z) continue; // stay inside
            if (ay<=0||ay>=CHUNK.Y) continue;
            const d2 = dx*dx + dy*dy + dz*dz;
            if (d2 <= 3 + (rng()<0.2?0:1)){
              if (!(dx===0 && dz===0 && dy<=0)){                // don't overwrite trunk core
                if (cGet(chunk, ax,ay,az) === BLOCK.AIR){
                  cSet(chunk, ax,ay,az, LEAVES);
                }
              }
            }
          }
        }
      }
    }

    function enqueueBuild(ch){ if (!buildQueue.includes(ch)) buildQueue.push(ch); }
    function buildMesh(c){
      if (!c.dirty) return;
      c.dirty = false;
      if(c.mesh){
        scene.remove(c.mesh);
        c.mesh.geometry.dispose();
        c.mesh.castShadow = true;
        c.mesh.receiveShadow = true;

        // DO NOT dispose shared material
        // c.mesh.material.dispose?.();
        c.mesh = null;
      }
    
      const pos=[], norm=[], uv=[];
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
    
      const pushTri=(a,b,cpt,n,rect)=>{
        pos.push(a.x,a.y,a.z, b.x,b.y,b.z, cpt.x,cpt.y,cpt.z);
        norm.push(n.x,n.y,n.z, n.x,n.y,n.z, n.x,n.y,n.z);
        uv.push(rect.u0,rect.v0,  rect.u1,rect.v0,  rect.u1,rect.v1);
      };
      const pushQuad=(p0,p1,p2,p3,n,rect)=>{
        pushTri(p0,p1,p2,n,rect);
        pos.push(p0.x,p0.y,p0.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z);
        norm.push(n.x,n.y,n.z,   n.x,n.y,n.z,   n.x,n.y,n.z);
        uv.push(rect.u0,rect.v0, rect.u1,rect.v1, rect.u0,rect.v1);
      };
    
      const addFace=(x,y,z,dir,blockId)=>{
        const bx=baseX+x, by=y, bz=baseZ+z;
        const rect = uvFor(blockId, dir);
        switch(dir){
          case 0:
            pushQuad(
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(1,0,0), rect); break;
          case 1:
            pushQuad(
              new THREE.Vector3(bx,by,  bz+1),
              new THREE.Vector3(bx,by+1,bz+1),
              new THREE.Vector3(bx,by+1,bz),
              new THREE.Vector3(bx,by,  bz),
              new THREE.Vector3(-1,0,0), rect); break;
          case 2:
            pushQuad(
              new THREE.Vector3(bx,  by+1,bz),
              new THREE.Vector3(bx,  by+1,bz+1),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(0,1,0), rect); break;
          case 3:
            pushQuad(
              new THREE.Vector3(bx,  by,  bz+1),
              new THREE.Vector3(bx,  by,  bz),
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(0,-1,0), rect); break;
          case 4:
            pushQuad(
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx,  by+1,bz+1),
              new THREE.Vector3(bx,  by,  bz+1),
              new THREE.Vector3(0,0,1), rect); break;
          case 5:
            pushQuad(
              new THREE.Vector3(bx,  by,  bz),
              new THREE.Vector3(bx,  by+1,bz),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(0,0,-1), rect); break;
        }
      };
    
      for(let y=0;y<CHUNK.Y;y++){
        for(let z=0;z<CHUNK.Z;z++){
          for(let x=0;x<CHUNK.X;x++){
            const id=c.blocks[idx(x,y,z)];
            if(id===BLOCK.AIR) continue;
            for(let d=0;d<6;d++){
              const nb=neighborBlock(c,x,y,z,d);
              if (shouldDrawFace(id, nb)) addFace(x,y,z,d,id);
            }
          }
        }
      }
    
      const geom=new THREE.BufferGeometry();
      geom.setAttribute("position",new THREE.Float32BufferAttribute(pos,3));
      geom.setAttribute("normal",new THREE.Float32BufferAttribute(norm,3));
      geom.setAttribute("uv",new THREE.Float32BufferAttribute(uv,2));
      geom.computeBoundingSphere();
    
      c.mesh=new THREE.Mesh(geom, CHUNK_MAT);
      c.mesh.castShadow = true;
      c.mesh.receiveShadow = true;
      scene.add(c.mesh);
    }
    /* ===== World management ===== */
    
    /* Strong break that always rebuilds the mesh */
    function breakBlockAt(wx, wy, wz){
      // make sure we address exact voxel cells
      wx = Math.floor(wx); wy = Math.floor(wy); wz = Math.floor(wz);
    
      const bid = getBlock(wx, wy, wz);
      // Early out if it's air or unbreakable
      const def = (typeof BLOCK_BY_ID !== "undefined") ? BLOCK_BY_ID[bid] : null;
      if (bid === BLOCK.AIR || (def && def.break === false)) return;
    
      // compute drops (block → item id string)
      const drops = (typeof getDrops === "function")
        ? getDrops(bid)                         // if you have a custom table
        : [ { id: itemIdFromBlockId(bid), count: 1 } ]; // default: block → same item
          
      for (const d of drops){
        const leftover = INV3.addDrop(makeStack(d.id, d.count));
        if (!isEmpty(leftover)){
          // TODO: spawn world item entity; for now just log
          console.log("Inventory full, leftover:", leftover.id, leftover.count);
        }
      }
      // Remove the block
      setBlock(wx, wy, wz, BLOCK.AIR);
    
      // Force the owning chunk to rebuild (important!)
      try {
        const cx = Math.floor(wx / CHUNK.X), cz = Math.floor(wz / CHUNK.Z);
        const ch = chunks.get(key(cx, cz));
        if (ch){
          ch.dirty = true;
          if (typeof enqueueBuild === "function") enqueueBuild(ch);
          if (typeof markNeighborsDirty === "function") markNeighborsDirty(cx, cz);
        }
      } catch (e){ /* noop */ }
      repaintHotbar();
      repaintBackpack();
    
    }
    function tryConsumeSelected(){
      // selected hotbar slot
      const slot = INV3.getSelectedSlot();
      if (!slot) return false;
    
      const st = slot.stack;
      if (isEmpty(st)) return false;        // nothing to place
    
      // must match the block you’re placing
      const needItemId = itemIdFromBlockId(CURRENT_BLOCK);
      if (st.id !== needItemId) return false;
    
      // consume exactly 1
      takeFrom(st, 1);
    
      // notify UI for that slot
      INV3.hotbar.touch(INV3.selectedIndex);
    
      // (optional) if stack emptied, you can also clear CURRENT_BLOCK or leave as is
      return true;
    }

    let lastChunkX = Infinity, lastChunkZ = Infinity;
    function ensureChunk(cx,cz){
      const k = key(cx,cz);
      let ch = chunks.get(k);
      if(!ch){ ch=new Chunk(cx,cz); chunks.set(k,ch); }
      if(!ch.generated) generateChunk(ch);
      return ch;
    }
    function scheduleGridRefresh(){ lastChunkX = Infinity; lastChunkZ = Infinity; }
    function updateVisibleGridIfNeeded(wx,wz){
      const pcx=Math.floor(wx/CHUNK.X), pcz=Math.floor(wz/CHUNK.Z);
      if (pcx === lastChunkX && pcz === lastChunkZ) return;
      lastChunkX = pcx; lastChunkZ = pcz;
      for(let dz=-GRID_RADIUS;dz<=GRID_RADIUS;dz++){
        for(let dx=-GRID_RADIUS;dx<=GRID_RADIUS;dx++){
          const ch = ensureChunk(pcx+dx, pcz+dz);
          if (ch.dirty) enqueueBuild(ch);
        }
      }
    }
    function markNeighborsDirty(cx, cz){
      const offsets = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dx,dz] of offsets){
        const nb = chunks.get(key(cx+dx, cz+dz));
        if (nb && nb.generated){ nb.dirty = true; enqueueBuild(nb); }
      }
    }
    function regenAll(){
      for(const [,ch] of chunks){
        if(ch.mesh){ scene.remove(ch.mesh); ch.mesh.geometry.dispose(); /* keep material */ }
      }
      chunks.clear();
      buildQueue.length = 0;
      scheduleGridRefresh();
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for(const [,ch] of chunks){ ch.dirty = true; enqueueBuild(ch); }
    }

    /* ===== Block Editing ===== */
    function getBlock(wx,wy,wz){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return BLOCK.AIR;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return BLOCK.AIR;
      return ch.blocks[idx(lx,ly,lz)];
    }
    function setBlock(wx,wy,wz,id){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return;

      const i = idx(lx,ly,lz);
      if (ch.blocks[i] === id) return;
      ch.blocks[i]=id;
      ch.dirty = true; enqueueBuild(ch);

      const mark = (nx,nz)=>{
        const nb = chunks.get(key(nx,nz));
        if (nb && nb.generated) { nb.dirty = true; enqueueBuild(nb); }
      };
      if (lx === 0)           mark(cx-1, cz);
      if (lx === CHUNK.X-1)   mark(cx+1, cz);
      if (lz === 0)           mark(cx, cz-1);
      if (lz === CHUNK.Z-1)   mark(cx, cz+1);
    }

    /* ===== Player & Picking & Physics ===== */
    // find surface height at (0,0)
    const groundY = surfaceYAt(0, 0);  // helper from step 1
    // start one block above it
    const player = {
      pos: new THREE.Vector3(0.5, groundY + 1.01, 0.5), // 0.5 = center of block
      vel: new THREE.Vector3(),
      size: new THREE.Vector3(0.6, 1.2, 0.6),
      grounded: false
    };

    function eyePos(){ return player.pos.clone().add(new THREE.Vector3(0, player.size.y*0.75, 0)); }
    // Precise voxel raycast (Amanatides & Woo)
    function pick(maxDist = 8) {
      const origin = eyePos();
      const dir = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
      if (dir.lengthSq() === 0) return { hit:false };
      dir.normalize();
    
      // current voxel
      let x = Math.floor(origin.x);
      let y = Math.floor(origin.y);
      let z = Math.floor(origin.z);
    
      // step and initial tMax/tDelta for each axis
      const stepX = dir.x > 0 ? 1 : -1;
      const stepY = dir.y > 0 ? 1 : -1;
      const stepZ = dir.z > 0 ? 1 : -1;
    
      const invX = dir.x !== 0 ? 1 / dir.x : Infinity;
      const invY = dir.y !== 0 ? 1 / dir.y : Infinity;
      const invZ = dir.z !== 0 ? 1 / dir.z : Infinity;
    
      const nextVoxelBoundary = (o, s, v) => (s > 0 ? v + 1 - o : o - v);
    
      let tMaxX = invX === Infinity ? Infinity : Math.abs(nextVoxelBoundary(origin.x, stepX, x) * invX);
      let tMaxY = invY === Infinity ? Infinity : Math.abs(nextVoxelBoundary(origin.y, stepY, y) * invY);
      let tMaxZ = invZ === Infinity ? Infinity : Math.abs(nextVoxelBoundary(origin.z, stepZ, z) * invZ);
    
      const tDeltaX = Math.abs(invX);
      const tDeltaY = Math.abs(invY);
      const tDeltaZ = Math.abs(invZ);
    
      // track which face we just crossed to compute normal
      let faceNormal = new THREE.Vector3(0,0,0);
    
      // visit the starting voxel too (in case you're “inside” a block)
      const maxT = maxDist;
      let t = 0;
    
      // helper to test the current voxel
      const isSolid = () => getBlock(x, y, z) !== BLOCK.AIR;
    
      if (isSolid()) {
        // we're already inside a block: normal points opposite the smallest tMax axis
        // pick the axis with smallest tMax to indicate which face we hit entering
        if (tMaxX <= tMaxY && tMaxX <= tMaxZ) faceNormal.set(-stepX, 0, 0);
        else if (tMaxY <= tMaxX && tMaxY <= tMaxZ) faceNormal.set(0, -stepY, 0);
        else faceNormal.set(0, 0, -stepZ);
        const pos = new THREE.Vector3(x, y, z);
        const place = pos.clone().add(faceNormal); // place on the face you are looking at
        return { hit:true, pos, normal: faceNormal.clone(), place };
      }
    
      // march through voxels
      while (t <= maxT) {
        // advance to next voxel boundary on the smallest tMax axis
        if (tMaxX <= tMaxY && tMaxX <= tMaxZ) {
          x += stepX; t = tMaxX; tMaxX += tDeltaX; faceNormal.set(-stepX, 0, 0);
        } else if (tMaxY <= tMaxX && tMaxY <= tMaxZ) {
          y += stepY; t = tMaxY; tMaxY += tDeltaY; faceNormal.set(0, -stepY, 0);
        } else {
          z += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; faceNormal.set(0, 0, -stepZ);
        }
      
        if (t > maxT) break;
      
        if (isSolid()) {
          const pos = new THREE.Vector3(x, y, z);
          const place = pos.clone().add(faceNormal); // the adjacent empty voxel on the hit face
          return { hit:true, pos, normal: faceNormal.clone(), place };
        }
      }
    
      return { hit:false };
    }

        addEventListener("mousedown", (e) => {
          if (!pointerLocked) return;
          const p = pick(REACH_DISTANCE);
          if (!p.hit) return;
        
          if (e.button === 0) {
            breakBlockAt(p.pos.x, p.pos.y, p.pos.z);
          } else if (e.button === 2) {
            const tx = p.place.x, ty = p.place.y, tz = p.place.z;
            if (wouldCollideWithPlayer(tx, ty, tz)) return;
          
            if (tryConsumeSelected()) {
              setBlock(tx, ty, tz, CURRENT_BLOCK);
            } else {
              // optional: out-of-items feedback
              // console.log("No more items in selected slot");
            }
          }
        });

      
        const EPS = 0.001;
        function eachCollidingBlock(pos, size, cb){
          const half = size.clone().multiplyScalar(0.5);
          const pMin = pos.clone().sub(half);
          const pMax = pos.clone().add(half);
          const minX=Math.floor(pMin.x), maxX=Math.floor(pMax.x);
          const minY=Math.floor(pMin.y), maxY=Math.floor(pMax.y);
          const minZ=Math.floor(pMin.z), maxZ=Math.floor(pMax.z);
          for(let x=minX;x<=maxX;x++){
            for(let y=minY;y<=maxY;y++){
              for(let z=minZ;z<=maxZ;z++){
                if(getBlock(x,y,z)!==BLOCK.AIR){
                  cb(new THREE.Vector3(x,y,z), new THREE.Vector3(x+1,y+1,z+1));
                }
              }
            }
          }
        }
    function moveAndCollide(dtFactor){
      player.grounded=false;

      // Y
      const prevVy = player.vel.y;
      const wasGrounded = player.grounded;
      player.pos.y += player.vel.y * dtFactor;
      const halfY = player.size.y * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinY=player.pos.y-halfY, pMaxY=player.pos.y+halfY;
        if (player.vel.y > 0 && pMinY < bMax.y && pMaxY > bMin.y){
          player.pos.y = bMin.y - halfY - EPS; player.vel.y = 0;
        }
        if (player.vel.y < 0 && pMaxY > bMin.y && pMinY < bMax.y){
          player.pos.y = bMax.y + halfY + EPS; player.vel.y = 0; player.grounded = true;
        }
        // landed this frame?
        if (!wasGrounded && player.grounded){
          const impact = Math.max(0, -prevVy); // downward speed when we hit
          const SAFE = 7.0;                    // tweak: no damage below this
          if (impact > SAFE){
            const dmg = (impact - SAFE) * 0.4; // scale to feel like hearts
            takeDamage(dmg);
          }
        }
      });

      // X
      player.pos.x += player.vel.x * dtFactor;
      const halfX = player.size.x * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinX=player.pos.x-halfX, pMaxX=player.pos.x+halfX;
        if (player.vel.x > 0 && pMaxX > bMin.x && pMinX < bMax.x){
          player.pos.x = bMin.x - halfX - EPS; player.vel.x = 0;
        } else if (player.vel.x < 0 && pMinX < bMax.x && pMaxX > bMin.x){
          player.pos.x = bMax.x + halfX + EPS; player.vel.x = 0;
        }
      });

      // Z
      player.pos.z += player.vel.z * dtFactor;
      const halfZ = player.size.z * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinZ=player.pos.z-halfZ, pMaxZ=player.pos.z+halfZ;
        if (player.vel.z > 0 && pMaxZ > bMin.z && pMinZ < bMax.z){
          player.pos.z = bMin.z - halfZ - EPS; player.vel.z = 0;
        } else if (player.vel.z < 0 && pMinZ < bMax.z && pMaxZ > bMin.z){
          player.pos.z = bMax.z + halfZ + EPS; player.vel.z = 0;
        }
      });
    }

    function scheduleFriction(dt){
      const DRAG = 16;                 // per-second drag (tweak 5–8)
      const f = Math.exp(-DRAG * dt); // exponential decay
      player.vel.x *= f;
      player.vel.z *= f;
    }

    // ---- Solidity helpers (no BLOCK_BY_ID required) ----
    const SOLID_SET = new Set([
      BLOCK.STONE, BLOCK.DIRT, BLOCK.GRASS, BLOCK.GLASS,
      BLOCK.LOG, BLOCK.LEAVES
    ]);

    function isSolid(id){ return SOLID_SET.has(id); }

    // Safe block read that never triggers gen
    function safeGetBlock(wx, wy, wz){
      const x = Math.floor(wx), y = Math.floor(wy), z = Math.floor(wz);
      const cx = Math.floor(x / CHUNK.X), cz = Math.floor(z / CHUNK.Z);
      const ch = chunks.get(key(cx, cz));
      if (!ch || !ch.generated) return BLOCK.AIR;
      const lx = x - cx * CHUNK.X, ly = y, lz = z - cz * CHUNK.Z;
      if (lx<0||lx>=CHUNK.X || ly<0||ly>=CHUNK.Y || lz<0||lz>=CHUNK.Z) return BLOCK.AIR;
      return ch.blocks[idx(lx, ly, lz)] ?? BLOCK.AIR;
    }
    function solidAtSafe(wx, wy, wz){ return isSolid(safeGetBlock(wx, wy, wz)); }
    function centerSupportedAt(x, z, feetY){ return solidAtSafe(x, feetY - 1, z); }

    /* ===== Startup & Loop ===== */
    regenAll();
    buildHotbar();
    buildInventory();
    paintStats();
    player.groundedLast = false; // optional, not required by our patch but fine

    INV3.hotbar.notify([...Array(9).keys()]);
    INV3.backpack.notify([...Array(27).keys()]);

    /* ===== STEP 3 hooks: wire containers -> your existing UI ===== */   

    // HOTBAR
    INV3.hotbar.events.on("slotsChanged", (idxs)=>{
      const icons  = document.querySelectorAll("#hotbarSlots .hotIcon");
      const counts = document.querySelectorAll("#hotbarSlots .hotCount");
      for (const i of idxs){
        const stack = INV3.hotbar.get(i)?.stack;
        const icon  = icons[i];
        const lbl   = counts[i];
        if (!icon || !lbl) continue;
      
        if (!stack || !stack.id || stack.count <= 0){
          icon.style.visibility = "hidden";   // <- prevents “stone by default”
          lbl.textContent = "";               // <- no number
        } else {
          icon.style.visibility = "visible";
          setIconBG(icon, blockNumFromItemId(stack.id));
          lbl.textContent = (stack.count > 1) ? String(stack.count) : "";
        }
      }
    });

    // BACKPACK
    INV3.backpack.events.on("slotsChanged", (idxs)=>{
      for (const i of idxs){
        const cell  = document.querySelector(`#invBackpack [data-key="bag:${i}"]`);
        if (!cell) continue;
        const icon  = cell.querySelector(".invIcon");   // NOTE: .invIcon class in backpack
        const lbl   = cell.querySelector(".invCount");
        const stack = INV3.backpack.get(i)?.stack;
      
        if (!stack || !stack.id || stack.count <= 0){
          icon.style.visibility = "hidden";
          lbl.textContent = "";
        } else {
          icon.style.visibility = "visible";
          setIconBG(icon, blockNumFromItemId(stack.id));
          lbl.textContent = (stack.count > 1) ? String(stack.count) : "";
        }
      }
    });



    // 3.h3) drive selector when selection changes
    INV3.onSelectChanged = (i)=>{
      moveSelector(i);
      // optional: set CURRENT_BLOCK to match selected stack (if it’s a block)
      const st = INV3.getSelectedSlot()?.stack;
      if (st && st.id){
        const bnum = blockNumFromItemId(st.id);
        if (Number.isFinite(bnum)) CURRENT_BLOCK = bnum;
      }
    };    

    // 3.h4) keep your 1..9 keys/wheel in sync with INV3 selection
    addEventListener("keydown", (e)=>{
      if (e.repeat) return;
      const d = e.keyCode - 49; // '1' => 0
      if (d>=0 && d<=8){ INV3.select(d); }
    });
    addEventListener("wheel",(e)=>{
      INV3.cycle(e.deltaY>0 ? 1 : -1);
    });   

    // 3.h5) helper: itemId("stone") -> BLOCK numeric (for setIconBG/CURRENT_BLOCK)
    function blockNumFromItemId(itemId){
      // uses BLOCK_NAME from step 1
      for (const num in BLOCK_NAME){
        if (BLOCK_NAME[num] === itemId) return Number(num);
      }
      return BLOCK.STONE; // fallback
    }
    // add this near your UI code (after hotbar is built)
    function moveSelector(i){
      const slots = document.querySelectorAll("#hotbarSlots .hotCell");
      slots.forEach((slot, idx)=>{
        if (idx === i) slot.classList.add("selected");
        else slot.classList.remove("selected");
      });
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function takeDamage(amount){
      if (STATS.invuln > 0) return;
      STATS.hp = clamp(STATS.hp - Math.ceil(amount), 0, STATS.hpMax);
      STATS.invuln = 0.6;
    /*
      // trigger camera nudge
      HurtCam.t = HurtCam.dur;
      HurtCam.dir = (Math.random()<0.5 ? -1 : 1); // left or right tilt
    */
      paintStats();
      if (STATS.hp <= 0) respawnPlayer();
    }



    function healSmall(dt){
      // tiny passive regen when well fed
      if (STATS.food >= 18 && STATS.hp < STATS.hpMax){
        STATS.satur -= dt * 0.8;
        if (STATS.satur <= 0){
          STATS.satur = 2;
          STATS.hp = clamp(STATS.hp + 1, 0, STATS.hpMax);
          paintStats();
        }
      }
    }

    function consumeFood(k){
      STATS.food = clamp(STATS.food + k, 0, STATS.foodMax);
      paintStats();
    }

    function hungerTick(dt, moving){
      const base = 0.01, move = moving ? 0.03 : 0.0; // tweak feel
      STATS.satur -= (base + move) * dt;
      if (STATS.satur <= 0){
        STATS.satur = 4;
        STATS.food = clamp(STATS.food - 1, 0, STATS.foodMax);
        paintStats();
      }
      // gentle starvation (stops at 0)
      if (STATS.food <= 0 && STATS.hp > 0){
        // small drip every second-ish
        STATS.invuln = Math.max(STATS.invuln, 0.9);
        takeDamage(1);
      }
    }

    function respawnPlayer(){
      const gx = 0, gz = 0;                  // fixed spawn coords
      const gy = surfaceYAt(gx, gz) + 2.01;  // 2 blocks above ground for safety
      player.pos.set(gx + 0.5, gy, gz + 0.5);
      player.vel.set(0,0,0);
    
      STATS.hp    = STATS.hpMax;
      STATS.food  = 20;
      STATS.satur = 5;
      STATS.invuln = 1.0;
      paintStats();
      console.log("Respawned at spawn (0,0) on Y:", gy);
    }

    // --- Fixed timestep loop ---
    let last = performance.now();
    let acc = 0;
    const STEP = 1/120; // physics step (seconds)

    function gameStep(dt){
      // --- look ---
      //camera.rotation.set(pitch, yaw, 0, "YXZ");
      // in gameStep(dt) after you update yaw/pitch from mouse:
      const shake = stepHurtShake(dt);

      // keep your normal pitch clamp, then add shake
      const pitchFinal = THREE.MathUtils.clamp(pitch + shake.pitch, -Math.PI/2+0.01, Math.PI/2-0.01);
      const yawFinal   = yaw + shake.yaw;

      camera.rotation.set(pitchFinal, yawFinal, shake.roll, "YXZ");

      // --- movement vectors ---
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(-1).normalize();
      const right   = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
    
      if (movementEnabled()){
        let speed = WALK;
        if (keys.has("z"))     speed = WALK * RUN_MULT;
        if (keys.has("shift")) speed = WALK * CROUCH_MULT;
      
        if (keys.has("w")) player.vel.addScaledVector(forward,  speed*dt);
        if (keys.has("s")) player.vel.addScaledVector(forward, -speed*dt);
        if (keys.has("a")) player.vel.addScaledVector(right,   -speed*dt);
        if (keys.has("d")) player.vel.addScaledVector(right,    speed*dt);
        if (keys.has(" ") && player.grounded) player.vel.y = JUMP_VEL;
      }

    
      // --- gravity & sun ---
      player.vel.y += GRAVITY * dt;
      updateSun(dt);
    
      // --- save pos before physics (for sneak edge revert) ---
      const prevX = player.pos.x, prevZ = player.pos.z;
      const feetY = Math.floor(player.pos.y - 0.1);
    
      // --- physics & collision ---
      moveAndCollide(dt);
      scheduleFriction(dt);
    
      // --- sneak: don't step off edges (post-move, safe) ---
      if (keys.has("shift") && player.grounded){
        const nowSupported  = centerSupportedAt(player.pos.x, player.pos.z, feetY);
        const prevSupported = centerSupportedAt(prevX,        prevZ,        feetY);
        if (!nowSupported && prevSupported){
          player.pos.x = prevX; player.vel.x = 0;
          player.pos.z = prevZ; player.vel.z = 0;
        }
      }
      // === survival ticks ===
      STATS.invuln = Math.max(0, STATS.invuln - dt);
      const moving = keys.has("w")||keys.has("a")||keys.has("s")||keys.has("d")||keys.has("z");
      hungerTick(dt, moving);
      healSmall(dt);

    
      // --- camera (smooth eye height when crouched) ---
      const eyeStand  = player.size.y * 0.75;
      const eyeCrouch = eyeStand - 0.30;
      const targetEye = keys.has("shift") ? eyeCrouch : eyeStand;
      eyeY += (targetEye - eyeY) * Math.min(1, dt * 10);
      camera.position.copy(player.pos).add(new THREE.Vector3(0, eyeY, 0));
    
      // --- chunk loading & meshing ---
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for (let i=0; i<BUILDS_PER_FRAME && buildQueue.length; i++){
        buildMesh(buildQueue.shift());
      }
    
      info.textContent =
        `Pos ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)} | ` +
        `grounded:${player.grounded} | queue:${buildQueue.length}`;
    }

    function loop(now){
      acc += Math.min(0.1, (now - last) / 1000); // accumulate dt, clamp big gaps
      last = now;

      while (acc >= STEP){
        gameStep(STEP);
        acc -= STEP;
      }

      renderer.render(scene,camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
