<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Voxel World with Trees</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b1020; }
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 8px 10px;
      background: rgba(0,0,0,0.45); color: #e5e7eb; font: 12px/1.4 system-ui, sans-serif;
      border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; backdrop-filter: blur(4px);
    }
    #hud b { color:#fff; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Voxel Trees Demo</b></div>
    <div>WASD to move • Space to jump • Shift to descend</div>
    <div>Chunks stream around you. Trees appear on grass.</div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ====== Config ======
    const WORLD_SEED = 12345;
    const CHUNK = { X: 32, Y: 64, Z: 32 };
    const VIEW_DIST = 3; // chunks radius to generate around player
    const BLOCK = { AIR:0, STONE:1, DIRT:2, GRASS:3, GLASS:4, LOG:5, LEAVES:6 };
    const BLOCK_TRANSPARENT = {
      [BLOCK.AIR]: true, [BLOCK.LEAVES]: true, [BLOCK.GLASS]: true
    };

    // simple palette (vertex colors)
    const BLOCK_COLOR = {
      [BLOCK.STONE]: new THREE.Color(0x7a7a7a),
      [BLOCK.DIRT]: new THREE.Color(0x6b4f27),
      [BLOCK.GRASS]: new THREE.Color(0x3aa655),
      [BLOCK.GLASS]: new THREE.Color(0xa7d5ff),
      [BLOCK.LOG]: new THREE.Color(0x8b5a2b),
      [BLOCK.LEAVES]: new THREE.Color(0x2f7d32)
    };

    // ====== Three.js setup ======
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.008);

    const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
    camera.position.set(16, 32, 16);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 1.0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.7, 1, 0.4);
    scene.add(dir);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    // ====== Utils ======
    function key(cx, cz){ return cx + "," + cz; }
    function idx(x,y,z){ return x + CHUNK.X*(z + CHUNK.Z*y); }
    function inBounds(x,y,z){ return x>=0&&x<CHUNK.X&&y>=0&&y<CHUNK.Y&&z>=0&&z<CHUNK.Z; }

    // Seeded RNG
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // Very light 2D value noise (seeded)
    class ValueNoise2D {
      constructor(seed=1){
        this.rand = mulberry32(seed>>>0);
        this.grid = new Map();
      }
      _h(ix, iz){
        const k = (ix<<16) ^ (iz&0xffff);
        if (!this.grid.has(k)){
          // deterministic pseudo random value -1..1
          const r = Math.sin(k*374761393 + 668265263) * 43758.5453123;
          this.grid.set(k, (r - Math.floor(r)) * 2 - 1);
        }
        return this.grid.get(k);
      }
      _lerp(a,b,t){ return a + (b-a)*t; }
      _smooth(t){ return t*t*(3-2*t); }
      sample(x, z, freq=0.01){
        const xf = x*freq, zf = z*freq;
        const x0 = Math.floor(xf), z0 = Math.floor(zf);
        const tx = this._smooth(xf - x0), tz = this._smooth(zf - z0);
        const v00 = this._h(x0, z0);
        const v10 = this._h(x0+1, z0);
        const v01 = this._h(x0, z0+1);
        const v11 = this._h(x0+1, z0+1);
        const vx0 = this._lerp(v00, v10, tx);
        const vx1 = this._lerp(v01, v11, tx);
        return this._lerp(vx0, vx1, tz); // -1..1
      }
      fbm(x,z, oct=4, baseFreq=0.01, gain=0.5){
        let amp=1, freq=baseFreq, sum=0, norm=0;
        for(let i=0;i<oct;i++){
          sum += this.sample(x,z,freq)*amp;
          norm += amp;
          amp *= gain; freq *= 2;
        }
        return sum/norm; // -1..1
      }
    }
    const noise = new ValueNoise2D(WORLD_SEED);

    // ====== Chunk data structure ======
    class Chunk {
      constructor(cx, cz){
        this.cx=cx; this.cz=cz;
        this.blocks = new Uint8Array(CHUNK.X*CHUNK.Y*CHUNK.Z);
        this.generated = false;
        this.mesh = null;
      }
      get(lx, y, lz){
        if (!inBounds(lx,y,lz)) return BLOCK.AIR;
        return this.blocks[idx(lx,y,lz)];
      }
      set(lx, y, lz, v){
        if (!inBounds(lx,y,lz)) return;
        this.blocks[idx(lx,y,lz)] = v;
      }
    }

    const chunks = new Map();

    // ====== Terrain generation ======
    function groundHeight(wx, wz){
      const h = 22 + Math.floor(14 * (noise.fbm(wx, wz, 5, 0.0075)*0.5 + 0.5));
      return THREE.MathUtils.clamp(h, 8, CHUNK.Y-8);
    }

    function generateChunk(c){
      if (c.generated) return;
      const baseX = c.cx * CHUNK.X;
      const baseZ = c.cz * CHUNK.Z;

      for (let z=0; z<CHUNK.Z; z++){
        for (let x=0; x<CHUNK.X; x++){
          const wx = baseX + x;
          const wz = baseZ + z;
          const h = groundHeight(wx, wz);

          for (let y=0; y<CHUNK.Y; y++){
            let id = BLOCK.AIR;
            if (y < h-4) id = BLOCK.STONE;
            else if (y < h-1) id = BLOCK.DIRT;
            else if (y === h-1) id = BLOCK.GRASS;
            c.set(x,y,z,id);
          }
        }
      }

      // === Decorate with trees (Step 5) ===
      decorateChunkTrees(c, WORLD_SEED, (x,z)=> noise.fbm(x,z,4,0.02,0.55));

      c.generated = true;
      buildMesh(c);
    }

    // ====== Tree placement ======
    function placeTreeWorld(wx, y, wz, rng){
      // find chunk for writing (supports crossing chunk borders)
      const cx = Math.floor(wx / CHUNK.X);
      const cz = Math.floor(wz / CHUNK.Z);
      ensureChunk(cx, cz); // ensure base chunk exists
      const R = 2;
      const h = 4 + Math.floor(rng()*3); // 4..6
      // trunk
      for (let i=0;i<h;i++) worldSet(wx, y+i, wz, BLOCK.LOG);
      const topY = y + h - 1;
      for (let dx=-R; dx<=R; dx++){
        for (let dy=-R; dy<=R; dy++){
          for (let dz=-R; dz<=R; dz++){
            const ax = wx+dx, ay = topY+dy, az = wz+dz;
            const d2 = dx*dx + dy*dy + dz*dz;
            if (d2 <= 3 + (rng()<0.2?0:1)) {
              if (!(dx===0 && dz===0 && dy<=0)) {
                if (worldGet(ax,ay,az) === BLOCK.AIR) worldSet(ax,ay,az,BLOCK.LEAVES);
              }
            }
          }
        }
      }
    }

    function decorateChunkTrees(chunk, worldSeed, noise2D){
      const { cx, cz } = chunk;
      const rng = mulberry32((worldSeed ^ (cx*73856093) ^ (cz*19349663)) >>> 0);
      const pad = 2;
      const sx = cx * CHUNK.X, sz = cz * CHUNK.Z;

      for (let lx=pad; lx<CHUNK.X-pad; lx++){
        for (let lz=pad; lz<CHUNK.Z-pad; lz++){
          const wx = sx + lx, wz = sz + lz;
          const dens = noise2D ? (noise2D(wx, wz)*0.5+0.5) : rng();
          if (dens < 0.66) continue;
          if (rng() > 0.18) continue;

          // find top
          let yTop = -1;
          for (let y=CHUNK.Y-2; y>=1; y--){
            const b = chunk.get(lx,y,lz);
            if (b !== BLOCK.AIR){ yTop = y; break; }
          }
          if (yTop < 0) continue;
          if (chunk.get(lx,yTop,lz) !== BLOCK.GRASS) continue;
          if (chunk.get(lx,yTop+1,lz) !== BLOCK.AIR) continue;

          // slope check
          const nbs = [
            columnTop(chunk,lx-1,lz), columnTop(chunk,lx+1,lz),
            columnTop(chunk,lx,lz-1), columnTop(chunk,lx,lz+1)
          ];
          const maxN = Math.max(...nbs), minN = Math.min(...nbs);
          if (maxN - minN > 2) continue;

          placeTreeWorld(wx, yTop+1, wz, rng);
        }
      }
    }
    function columnTop(chunk, lx, lz){
      if (lx<0||lx>=CHUNK.X||lz<0||lz>=CHUNK.Z) return -9999;
      for (let y=CHUNK.Y-2; y>=1; y--){
        if (chunk.get(lx,y,lz)!==BLOCK.AIR) return y;
      }
      return -9999;
    }

    // ====== World access spanning chunks ======
    function ensureChunk(cx, cz){
      const k = key(cx,cz);
      if (!chunks.has(k)){
        const c = new Chunk(cx,cz);
        chunks.set(k, c);
        generateChunk(c);
      }
      return chunks.get(k);
    }
    function worldGet(wx, y, wz){
      const cx = Math.floor(wx / CHUNK.X);
      const cz = Math.floor(wz / CHUNK.Z);
      const lx = ((wx%CHUNK.X)+CHUNK.X)%CHUNK.X;
      const lz = ((wz%CHUNK.Z)+CHUNK.Z)%CHUNK.Z;
      const c = ensureChunk(cx,cz);
      return c.get(lx,y,lz);
    }
    function worldSet(wx, y, wz, v){
      if (y<0 || y>=CHUNK.Y) return;
      const cx = Math.floor(wx / CHUNK.X);
      const cz = Math.floor(wz / CHUNK.Z);
      const lx = ((wx%CHUNK.X)+CHUNK.X)%CHUNK.X;
      const lz = ((wz%CHUNK.Z)+CHUNK.Z)%CHUNK.Z;
      const c = ensureChunk(cx,cz);
      c.set(lx,y,lz,v);
      // mark dirty for rebuild later (cheap: rebuild immediately for this demo)
      buildMesh(c);
    }

    // ====== Meshing (naive greedy-ish face adder) ======
    const geomPool = new THREE.BufferGeometry();
    function buildMesh(c){
      // remove old
      if (c.mesh){ worldGroup.remove(c.mesh); c.mesh.geometry.dispose(); }

      const positions = [];
      const colors = [];
      const normals = [];

      const v = new THREE.Vector3();
      const faces = [
        // [nx,ny,nz,  quad verts...]
        [ 1, 0, 0,  [1,0,0, 1,1,0, 1,1,1, 1,0,1] ],
        [-1, 0, 0,  [0,0,1, 0,1,1, 0,1,0, 0,0,0] ],
        [ 0, 1, 0,  [0,1,1, 1,1,1, 1,1,0, 0,1,0] ],
        [ 0,-1, 0,  [0,0,0, 1,0,0, 1,0,1, 0,0,1] ],
        [ 0, 0, 1,  [0,0,1, 1,0,1, 1,1,1, 0,1,1] ],
        [ 0, 0,-1,  [0,1,0, 1,1,0, 1,0,0, 0,0,0] ],
      ];

      function addQuad(x,y,z, face, col){
        const [nx,ny,nz, q] = face;
        const base = positions.length/3;
        for (let i=0;i<4;i++){
          positions.push(x+q[i*3+0], y+q[i*3+1], z+q[i*3+2]);
          normals.push(nx,ny,nz);
          colors.push(col.r, col.g, col.b);
        }
        // two triangles
        // (0,1,2) (0,2,3)
        indices.push(base, base+1, base+2, base, base+2, base+3);
      }

      const indices = [];
      for (let y=0;y<CHUNK.Y;y++){
        for (let z=0;z<CHUNK.Z;z++){
          for (let x=0;x<CHUNK.X;x++){
            const id = c.get(x,y,z);
            if (id===BLOCK.AIR) continue;
            const col = BLOCK_COLOR[id] || new THREE.Color(0xffffff);

            // neighbors
            if (x===CHUNK.X-1 || isTransparent(c.get(x+1,y,z))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[0], col);
            if (x===0          || isTransparent(c.get(x-1,y,z))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[1], col);
            if (y===CHUNK.Y-1 || isTransparent(c.get(x,y+1,z))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[2], col);
            if (y===0          || isTransparent(c.get(x,y-1,z))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[3], col);
            if (z===CHUNK.Z-1 || isTransparent(c.get(x,y,z+1))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[4], col);
            if (z===0          || isTransparent(c.get(x,y,z-1))) addQuad(c.cx*CHUNK.X + x, y, c.cz*CHUNK.Z + z, faces[5], col);
          }
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setIndex(indices);
      geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute("normal", new THREE.Float32BufferAttribute(normals, 3));
      geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeBoundingSphere();

      const material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        roughness: 1.0,
        metalness: 0.0,
        transparent: true,
        opacity: 1.0
      });

      c.mesh = new THREE.Mesh(geometry, material);
      worldGroup.add(c.mesh);
    }

    function isTransparent(id){
      return BLOCK_TRANSPARENT[id] === true;
    }

    // ====== Chunk streamer around camera ======
    function updateChunksAround(pos){
      const cx = Math.floor(pos.x / CHUNK.X);
      const cz = Math.floor(pos.z / CHUNK.Z);
      for (let dz=-VIEW_DIST; dz<=VIEW_DIST; dz++){
        for (let dx=-VIEW_DIST; dx<=VIEW_DIST; dx++){
          ensureChunk(cx+dx, cz+dz);
        }
      }
      // optional: remove far chunks (not implementing for simplicity)
    }

    // ====== Simple fly controls (WASD + Space + Shift) ======
    const keys = new Set();
    addEventListener("keydown", e => keys.add(e.key.toLowerCase()));
    addEventListener("keyup", e => keys.delete(e.key.toLowerCase()));
    let vel = new THREE.Vector3();
    const GRAV = -0.015, JUMP = 0.25;
    let onGround = false;
    function playerStep(dt){
      // horizontal move
      const sp = 6; // m/s
      const dir = new THREE.Vector3();
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      if (keys.has("w")) dir.add(forward);
      if (keys.has("s")) dir.addScaledVector(forward, -1);
      if (keys.has("a")) dir.addScaledVector(right, -1);
      if (keys.has("d")) dir.add(right);
      if (dir.lengthSq()>0) dir.normalize();
      camera.position.addScaledVector(dir, sp*dt);

      // simplistic vertical
      vel.y += GRAV;
      if (keys.has(" ") && onGround){ vel.y = JUMP; onGround=false; }
      if (keys.has("shift")) vel.y -= 0.02;
      camera.position.y += vel.y;

      // fake ground at y=groundHeight under player + 2
      const gh = groundHeight(camera.position.x, camera.position.z) + 2.0;
      if (camera.position.y <= gh){
        camera.position.y = gh; vel.y = 0; onGround = true;
      }
    }

    // ====== Loop ======
    let last = performance.now();
    function tick(){
      const now = performance.now();
      const dt = Math.min(0.05, (now-last)/1000); last = now;
      playerStep(dt);
      updateChunksAround(camera.position);
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

  </script>
</body>
</html>
