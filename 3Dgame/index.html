<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Voxel Prototype</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b1220;
      overflow: hidden;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      font: 14px ui-monospace, Consolas, monospace;
      color: #e9eefc;
      background: rgba(0,0,0,.35);
      padding: 8px 10px;
      border-radius: 10px;
      user-select: none;
      max-height: 95vh;
      overflow-y: auto;
    }
    #hud input[type=range] {
      width: 140px;
      vertical-align: middle;
      margin: 4px 6px;
    }

    #cross {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 18px;
      height: 18px;
      margin: -9px 0 0 -9px;
      pointer-events: none;
    }
    #cross:before, #cross:after {
      content: "";
      position: absolute;
      background: #e9eefc;
    }
    #cross:before { left: 8px; top: 0; width: 2px; height: 18px; }
    #cross:after  { top: 8px; left: 0; height: 2px; width: 18px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Voxel Prototype</b> — click to lock mouse</div>
    <div>WASD move • Space jump • Shift sprint • Left: break • Right: place • 1–4 block • R: regen</div>
    <div id="info"></div>

    <hr>
    <b>Movement</b><br>
    Gravity <input id="gSlider" type="range" min="-0.1" max="0" step="0.001" value="-0.027"> <span id="gVal"></span><br>
    JumpVel <input id="jSlider" type="range" min="0" max="0.5" step="0.01" value="0.14"> <span id="jVal"></span><br>
    WalkSpd <input id="wSlider" type="range" min="0" max="0.2" step="0.001" value="0.072"> <span id="wVal"></span><br>
    SprintSpd <input id="sSlider" type="range" min="0" max="0.2" step="0.001" value="0.093"> <span id="sVal"></span><br>

    <hr>
    <b>Render</b><br>
    RenderDist <input id="rSlider" type="range" min="0" max="8" step="1" value="2"> <span id="rVal"></span><br>
    Builds/frame <input id="bSlider" type="range" min="1" max="24" step="1" value="8"> <span id="bVal"></span><br>

    <hr>
    <b>Noise (Multiplicative)</b><br>
    MaskScale <input id="maskSlider" type="range" min="0.001" max="0.02" step="0.001" value="0.003"> <span id="maskVal"></span><br>
    HillScale <input id="hillSlider" type="range" min="0.01" max="0.08" step="0.001" value="0.02"> <span id="hillVal"></span><br>
    DetailScale <input id="detailSlider" type="range" min="0.05" max="0.3" step="0.005" value="0.08"> <span id="detailVal"></span><br>
    MountainAmp <input id="mountSlider" type="range" min="5" max="80" step="1" value="28"> <span id="mountVal"></span><br>
  </div>

  <div id="cross"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /* ===== Tunables (sliders override) ===== */
    let GRAVITY  = -0.027;
    let JUMP_VEL =  0.14;
    let WALK     =  0.072;
    let SPRINT   =  0.093;
    // --- Biome & shape tuning ---
    let BIOME_SCALE     = 0.0016;  // lower = larger biomes
    let WARP_SCALE      = 0.015;   // domain warping frequency
    let WARP_STRENGTH   = 12.0;    // how much to warp coordinates

    // Plains
    let PLAINS_BASE     = 28;      // base height
    let PLAINS_WOBBLE   = 2.5;     // tiny variation

    // Hills
    let HILLS_SCALE     = 0.02;    // hill frequency
    let HILLS_AMP       = 10;      // hill amplitude

    // Mountains (ridged)
    let MOUNT_SCALE     = 0.012;   // mountain frequency (larger features)
    let MOUNT_RIDGES    = 35;      // mountain height

    // “Hilly patches” sprinkled in plains
    let SPOT_SCALE      = 0.01;    // frequency of spots
    let SPOT_THRESHOLD  = 0.72;    // higher => fewer spots
    let SPOT_AMPLITUDE  = 7;       // bump height when a spot hits


    let GRID_RADIUS = 2;        // render distance
    let BUILDS_PER_FRAME = 8;   // throttle meshing

    // Multiplicative noise params (flats + mountains)
    let MASK_SCALE   = 0.003;
    let HILL_SCALE   = 0.02;
    let DETAIL_SCALE = 0.08;
    let MOUNT_AMP    = 28;

    /* ===== Config ===== */
    const CHUNK = { X:16, Y:64, Z:16 };
    const BLOCK = { AIR:0, STONE:1, GRASS:2, DIRT:3, GLASS:4 };
    let CURRENT_BLOCK = BLOCK.STONE;

    /* ===== Scene ===== */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);
    scene.fog = new THREE.Fog(0x0b1220, 80, 220);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xcfe8ff, 0x1a2438, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.7,1,0.4); scene.add(dir);

    const info = document.getElementById("info");

    /* ===== Input ===== */
    const keys = new Set();
    let pointerLocked = false;
    let yaw = 0, pitch = 0;

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
    document.body.addEventListener("click", () => {
      if (!pointerLocked) renderer.domElement.requestPointerLock();
    });
    document.addEventListener("pointerlockchange", () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
    });
    document.addEventListener("mousemove", (e) => {
      if (!pointerLocked) return;
      const sens = 0.0025, MAX_D = 80;
      const dx = Math.max(-MAX_D, Math.min(MAX_D, e.movementX||0));
      const dy = Math.max(-MAX_D, Math.min(MAX_D, e.movementY||0));
      yaw   -= dx * sens;
      pitch -= dy * sens;
      pitch = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001, pitch));
    });
    addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys.add(k);
      if (k==="1") CURRENT_BLOCK=BLOCK.STONE;
      if (k==="2") CURRENT_BLOCK=BLOCK.GRASS;
      if (k==="3") CURRENT_BLOCK=BLOCK.DIRT;
      if (k==="4") CURRENT_BLOCK=BLOCK.GLASS;
      if (k==="r") regenAll(); // rebuild with current sliders
    });
    addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
    addEventListener("contextmenu", (e) => e.preventDefault());

    /* ===== Slider bindings ===== */
    const bind = (id, setter, fmt=(v)=>v)=> {
      const el = document.getElementById(id);
      const out = document.getElementById(id.replace("Slider","Val"));
      const sync = ()=> { if(out) out.textContent = fmt(el.value); };
      el.addEventListener("input", (e)=>{ setter(parseFloat(e.target.value)); sync(); });
      sync();
    };
    bind("gSlider",   v => GRAVITY=v);
    bind("jSlider",   v => JUMP_VEL=v);
    bind("wSlider",   v => WALK=v);
    bind("sSlider",   v => SPRINT=v);
    bind("rSlider",   v => { GRID_RADIUS = v|0; scheduleGridRefresh(); }, v=>v|0);
    bind("bSlider",   v => { BUILDS_PER_FRAME = v|0; }, v=>v|0);
    bind("maskSlider",v => { MASK_SCALE=v; regenAll(); }, v=>(+v).toFixed(3));
    bind("hillSlider",v => { HILL_SCALE=v; regenAll(); }, v=>(+v).toFixed(3));
    bind("detailSlider",v=> { DETAIL_SCALE=v; regenAll(); }, v=>(+v).toFixed(3));
    bind("mountSlider", v=> { MOUNT_AMP=v; regenAll(); }, v=>v|0);
    // Ridged noise from fbm: sharp peaks for mountains
    function ridged(x, y, octaves=4){
      let amp=1, freq=1, sum=0, norm=0;
      for(let i=0;i<octaves;i++){
        // abs(0.5 - fbm) makes crests; 1 - ... inverts to peaks
        const r = 1.0 - Math.abs(0.5 - fbm2(x*freq, y*freq)) * 2.0;
        sum += r * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm; // ~0..1
    }

    // Simple domain warp: offset coords before sampling
    function warp2(x, y){
      // two low-mid frequency fbm fields to distort coordinates
      const wx = fbm2(x*WARP_SCALE*2.13, y*WARP_SCALE*0.91);
      const wy = fbm2(x*WARP_SCALE*1.31, y*WARP_SCALE*1.73);
      return { x: x + (wx-0.5)*2*WARP_STRENGTH, y: y + (wy-0.5)*2*WARP_STRENGTH };
    }

// Smoothstep helper for blending
function sstep(a,b,t){ const u=Math.max(0,Math.min(1,(t-a)/(b-a))); return u*u*(3-2*u); }

    /* ===== Noise ===== */
    function hash2i(x, y) {
      let h = x*374761393 + y*668265263;
      h = (h ^ (h>>13)) * 1274126177;
      return (h>>>0)/0xffffffff;
    }
    const smoothstep = t => t*t*(3-2*t);
    function valueNoise2(x,y){
      const xi=Math.floor(x), yi=Math.floor(y);
      const tx=x-xi, ty=y-yi;
      const a=hash2i(xi,yi), b=hash2i(xi+1,yi), c=hash2i(xi,yi+1), d=hash2i(xi+1,yi+1);
      const sx=smoothstep(tx), sy=smoothstep(ty);
      const u=a+(b-a)*sx, v=c+(d-c)*sx;
      return u+(v-u)*sy;
    }
    function fbm2(x,y){
      let amp=1,freq=1,sum=0,norm=0;
      for(let i=0;i<4;i++){
        sum+=valueNoise2(x*freq,y*freq)*amp;
        norm+=amp; amp*=0.5; freq*=2;
      }
      return sum/norm;
    }
    // Multiplicative terrain = flats + mountains
    function sampleTerrain(wx, wz) {
      // 1) Domain warp for more organic shapes
      const w = warp2(wx, wz);
      const x = w.x, y = w.y;
    
      // 2) Biome map (very low freq). We’ll split into 3 bands.
      const biomeN = fbm2(x*BIOME_SCALE, y*BIOME_SCALE); // 0..1
      // bands (tune these to shift coverage)
      const tPlains    = sstep(0.00, 0.40, biomeN);  // more weight when biomeN is low
      const tHills     = sstep(0.35, 0.70, biomeN);  // mid band
      const tMountains = sstep(0.65, 1.00, biomeN);  // high band
    
      // Normalize weights so they sum to 1 (soft overlap)
      const wSum = tPlains + tHills + tMountains + 1e-6;
      const bP = tPlains / wSum, bH = tHills / wSum, bM = tMountains / wSum;
    
      // 3) Plains generator: almost flat, tiny wobble
      const plains = PLAINS_BASE
                   + (fbm2(x*0.03, y*0.03) - 0.5) * 2 * PLAINS_WOBBLE;
    
      // 4) Hills generator: regular fbm bumps
      const hills = PLAINS_BASE + 3
                  + (fbm2(x*HILLS_SCALE, y*HILLS_SCALE)) * HILLS_AMP;
    
      // 5) Mountain generator: ridged for sharp peaks
      const mountains = PLAINS_BASE + 6
                      + ridged(x*MOUNT_SCALE, y*MOUNT_SCALE) * MOUNT_RIDGES;
    
      // 6) Sprinkle “hilly spots” inside otherwise flat zones
      //    Raise height locally when a spot noise exceeds a threshold.
      let spotBump = 0;
      const spot = fbm2(x*SPOT_SCALE, y*SPOT_SCALE); // 0..1
      if (spot > SPOT_THRESHOLD){
        // stronger bump nearer the center of the “spot”
        const k = (spot - SPOT_THRESHOLD) / (1 - SPOT_THRESHOLD); // 0..1
        spotBump = k * SPOT_AMPLITUDE;
      }
  
      // 7) Blend by biome
      let h = bP * plains + bH * hills + bM * mountains;
  
      // Let spots mostly affect plains & mild hills (not towering mountains)
      const spotWeight = bP * 1.0 + bH * 0.6; // bias towards plains
      h += spotBump * spotWeight;
  
      return Math.floor(h);
    }
    
    // For quick sanity: set to a number to force flat world (e.g., 20). Set to null to use noise.
    const FLAT_WORLD_Y = null;

    /* ===== World ===== */
    class Chunk {
      constructor(cx,cz){
        this.cx=cx; this.cz=cz;
        this.blocks=new Uint8Array(CHUNK.X*CHUNK.Y*CHUNK.Z);
        this.mesh=null;
        this.generated=false;
        this.dirty=false;
      }
    }
    const chunks = new Map();
    const buildQueue = []; // throttle meshing
    const key = (cx,cz)=>`${cx},${cz}`;
    const idx = (x,y,z)=> x + CHUNK.X*(z + CHUNK.Z*y);

    function generateChunk(c){
      if(c.generated) return;
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
      for(let z=0;z<CHUNK.Z;z++){
        for(let x=0;x<CHUNK.X;x++){
          const wx=baseX+x, wz=baseZ+z;
          const h= FLAT_WORLD_Y ?? sampleTerrain(wx,wz);
          for(let y=0;y<CHUNK.Y;y++){
            let id=BLOCK.AIR;
            if(y===h) id=BLOCK.GRASS;
            else if(y<h-3) id=BLOCK.STONE;
            else if(y<h) id=BLOCK.DIRT;
            c.blocks[idx(x,y,z)]=id;
          }
        }
      }
      c.generated=true;
      c.dirty=true;
      enqueueBuild(c);
    }

    function shouldDrawFace(cur, neighbor){
      if (neighbor === BLOCK.AIR) return true;
      if (neighbor === BLOCK.GLASS && cur !== BLOCK.GLASS) return true;
      return false;
    }
    function blockColor(id){
      switch(id){
        case BLOCK.STONE:return new THREE.Color(0x9aa0a6);
        case BLOCK.GRASS:return new THREE.Color(0x55aa55);
        case BLOCK.DIRT:return new THREE.Color(0x7a4e2a);
        case BLOCK.GLASS:return new THREE.Color(0x77c4ff);
      } return new THREE.Color(0,0,0);
    }
    function neighborBlock(c,x,y,z,dir){
      let nx=x,ny=y,nz=z,cx=c.cx,cz=c.cz;
      if(dir===0)nx++; if(dir===1)nx--;
      if(dir===2)ny++; if(dir===3)ny--;
      if(dir===4)nz++; if(dir===5)nz--;
      if(ny<0||ny>=CHUNK.Y) return BLOCK.AIR;
      if(nx<0){cx--;nx+=CHUNK.X;}
      if(nx>=CHUNK.X){cx++;nx-=CHUNK.X;}
      if(nz<0){cz--;nz+=CHUNK.Z;}
      if(nz>=CHUNK.Z){cz++;nz-=CHUNK.Z;}
      const nc=chunks.get(key(cx,cz));
      if(!nc||!nc.generated) return BLOCK.AIR;
      return nc.blocks[idx(nx,ny,nz)];
    }

    function buildMesh(c){
      if (!c.dirty) return;
      c.dirty = false;
      if(c.mesh){
        scene.remove(c.mesh);
        c.mesh.geometry.dispose();
        c.mesh.material.dispose();
        c.mesh = null;
      }

      const pos=[],norm=[],col=[];
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;

      const pushTri=(a,b,cpt,n,color)=>{
        pos.push(a.x,a.y,a.z, b.x,b.y,b.z, cpt.x,cpt.y,cpt.z);
        norm.push(n.x,n.y,n.z, n.x,n.y,n.z, n.x,n.y,n.z);
        for(let i=0;i<3;i++) col.push(color.r,color.g,color.b);
      };
      const pushQuad=(p0,p1,p2,p3,n,color)=>{ pushTri(p0,p1,p2,n,color); pushTri(p0,p2,p3,n,color); };

      // Correct face winding; material is DoubleSide to guarantee visibility
      const addFace=(x,y,z,dir,color)=>{
        const bx=baseX+x, by=y, bz=baseZ+z;
        switch(dir){
          case 0: // +X
            pushQuad(new THREE.Vector3(bx+1,by,bz),new THREE.Vector3(bx+1,by+1,bz),new THREE.Vector3(bx+1,by+1,bz+1),new THREE.Vector3(bx+1,by,bz+1),new THREE.Vector3(1,0,0),color); break;
          case 1: // -X
            pushQuad(new THREE.Vector3(bx,by,bz+1),new THREE.Vector3(bx,by+1,bz+1),new THREE.Vector3(bx,by+1,bz),new THREE.Vector3(bx,by,bz),new THREE.Vector3(-1,0,0),color); break;
          case 2: // +Y
            pushQuad(new THREE.Vector3(bx,by+1,bz),new THREE.Vector3(bx,by+1,bz+1),new THREE.Vector3(bx+1,by+1,bz+1),new THREE.Vector3(bx+1,by+1,bz),new THREE.Vector3(0,1,0),color); break;
          case 3: // -Y
            pushQuad(new THREE.Vector3(bx,by,bz+1),new THREE.Vector3(bx,by,bz),new THREE.Vector3(bx+1,by,bz),new THREE.Vector3(bx+1,by,bz+1),new THREE.Vector3(0,-1,0),color); break;
          case 4: // +Z
            pushQuad(new THREE.Vector3(bx+1,by,bz+1),new THREE.Vector3(bx+1,by+1,bz+1),new THREE.Vector3(bx,by+1,bz+1),new THREE.Vector3(bx,by,bz+1),new THREE.Vector3(0,0,1),color); break;
          case 5: // -Z
            pushQuad(new THREE.Vector3(bx,by,bz),new THREE.Vector3(bx,by+1,bz),new THREE.Vector3(bx+1,by+1,bz),new THREE.Vector3(bx+1,by,bz),new THREE.Vector3(0,0,-1),color); break;
        }
      };

      for(let y=0;y<CHUNK.Y;y++){
        for(let z=0;z<CHUNK.Z;z++){
          for(let x=0;x<CHUNK.X;x++){
            const id=c.blocks[idx(x,y,z)];
            if(id===BLOCK.AIR) continue;
            const color=blockColor(id);
            for(let d=0;d<6;d++){
              const nb=neighborBlock(c,x,y,z,d);
              if (shouldDrawFace(id, nb)) addFace(x,y,z,d,color);
            }
          }
        }
      }

      const geom=new THREE.BufferGeometry();
      geom.setAttribute("position",new THREE.Float32BufferAttribute(pos,3));
      geom.setAttribute("normal",new THREE.Float32BufferAttribute(norm,3));
      geom.setAttribute("color",new THREE.Float32BufferAttribute(col,3));
      geom.computeBoundingSphere();

      // DoubleSide so even if any winding goes wrong, you still see blocks
      const mat=new THREE.MeshLambertMaterial({
        vertexColors:true,fog:true,side:THREE.DoubleSide
      });

      c.mesh=new THREE.Mesh(geom,mat);
      scene.add(c.mesh);
    }

    function enqueueBuild(ch){ if (!buildQueue.includes(ch)) buildQueue.push(ch); }

    /* ===== World management ===== */
    let lastChunkX = Infinity, lastChunkZ = Infinity;
    function ensureChunk(cx,cz){
      const k = key(cx,cz);
      let ch = chunks.get(k);
      if(!ch){ ch=new Chunk(cx,cz); chunks.set(k,ch); }
      if(!ch.generated) generateChunk(ch);
      return ch;
    }
    function scheduleGridRefresh(){ lastChunkX = Infinity; lastChunkZ = Infinity; }
    function updateVisibleGridIfNeeded(wx,wz){
      const pcx=Math.floor(wx/CHUNK.X), pcz=Math.floor(wz/CHUNK.Z);
      if (pcx === lastChunkX && pcz === lastChunkZ) return;
      lastChunkX = pcx; lastChunkZ = pcz;
      for(let dz=-GRID_RADIUS;dz<=GRID_RADIUS;dz++){
        for(let dx=-GRID_RADIUS;dx<=GRID_RADIUS;dx++){
          const ch = ensureChunk(pcx+dx, pcz+dz);
          if (ch.dirty) enqueueBuild(ch);
        }
      }
    }
    function regenAll(){
      for(const [,ch] of chunks){
        if(ch.mesh){ scene.remove(ch.mesh); ch.mesh.geometry.dispose(); ch.mesh.material.dispose(); }
      }
      chunks.clear();
      buildQueue.length = 0;

      // force grid load around current player pos
      scheduleGridRefresh();
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);

      // mark & queue all loaded chunks immediately
      for(const [,ch] of chunks){
        ch.dirty = true;
        enqueueBuild(ch);
      }
    }

    /* ===== Block Editing ===== */
    function getBlock(wx,wy,wz){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return BLOCK.AIR;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return BLOCK.AIR;
      return ch.blocks[idx(lx,ly,lz)];
    }
    function setBlock(wx,wy,wz,id){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return;
      ch.blocks[idx(lx,ly,lz)]=id;
      ch.dirty = true;
      enqueueBuild(ch);
    }

    /* ===== Player & Picking & Physics ===== */
    const player = {
      pos: new THREE.Vector3(8, 60, 8),
      vel: new THREE.Vector3(),
      size: new THREE.Vector3(0.6, 1.8, 0.6),
      grounded: false
    };
    function eyePos(){ return player.pos.clone().add(new THREE.Vector3(0, player.size.y*0.75, 0)); }
    function pick(maxDist=8){
      const dir=new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch,yaw,0,"YXZ"));
      const pos=eyePos(); const step=0.1; let lastAir=pos.clone();
      for(let i=0;i<maxDist/step;i++){
        const b=getBlock(Math.floor(pos.x),Math.floor(pos.y),Math.floor(pos.z));
        if(b!==BLOCK.AIR) return {hit:true,pos:pos.clone().floor(),place:lastAir.clone().floor()};
        lastAir.copy(pos); pos.addScaledVector(dir,step);
      } return {hit:false};
    }
    addEventListener("mousedown",(e)=>{
      if(!pointerLocked) return;
      const p=pick(10); if(!p.hit) return;
      if(e.button===0) setBlock(p.pos.x,p.pos.y,p.pos.z,BLOCK.AIR);
      if(e.button===2) setBlock(p.place.x,p.place.y,p.place.z,CURRENT_BLOCK);
    });

    const EPS = 0.001;
    function eachCollidingBlock(pos, size, cb){
      const half = size.clone().multiplyScalar(0.5);
      const pMin = pos.clone().sub(half);
      const pMax = pos.clone().add(half);
      const minX=Math.floor(pMin.x), maxX=Math.floor(pMax.x);
      const minY=Math.floor(pMin.y), maxY=Math.floor(pMax.y);
      const minZ=Math.floor(pMin.z), maxZ=Math.floor(pMax.z);
      for(let x=minX;x<=maxX;x++){
        for(let y=minY;y<=maxY;y++){
          for(let z=minZ;z<=maxZ;z++){
            if(getBlock(x,y,z)!==BLOCK.AIR){
              cb(new THREE.Vector3(x,y,z), new THREE.Vector3(x+1,y+1,z+1));
            }
          }
        }
      }
    }
    function moveAndCollide(dtFactor){
      player.grounded=false;

      // Y
      player.pos.y += player.vel.y * dtFactor;
      const halfY = player.size.y * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinY=player.pos.y-halfY, pMaxY=player.pos.y+halfY;
        if (player.vel.y > 0 && pMinY < bMax.y && pMaxY > bMin.y){
          player.pos.y = bMin.y - halfY - EPS; player.vel.y = 0;
        }
        if (player.vel.y < 0 && pMaxY > bMin.y && pMinY < bMax.y){
          player.pos.y = bMax.y + halfY + EPS; player.vel.y = 0; player.grounded = true;
        }
      });

      // X
      player.pos.x += player.vel.x * dtFactor;
      const halfX = player.size.x * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinX=player.pos.x-halfX, pMaxX=player.pos.x+halfX;
        if (player.vel.x > 0 && pMaxX > bMin.x && pMinX < bMax.x){
          player.pos.x = bMin.x - halfX - EPS; player.vel.x = 0;
        } else if (player.vel.x < 0 && pMinX < bMax.x && pMaxX > bMin.x){
          player.pos.x = bMax.x + halfX + EPS; player.vel.x = 0;
        }
      });

      // Z
      player.pos.z += player.vel.z * dtFactor;
      const halfZ = player.size.z * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinZ=player.pos.z-halfZ, pMaxZ=player.pos.z+halfZ;
        if (player.vel.z > 0 && pMaxZ > bMin.z && pMinZ < bMax.z){
          player.pos.z = bMin.z - halfZ - EPS; player.vel.z = 0;
        } else if (player.vel.z < 0 && pMinZ < bMax.z && pMaxZ > bMin.z){
          player.pos.z = bMax.z + halfZ + EPS; player.vel.z = 0;
        }
      });
    }

    /* ===== Startup & Loop ===== */
    // 🔥 Ensure terrain shows on first load
    regenAll();

    let last = performance.now();
    function animate(now){
      const dt=(now-last)/1000; last=now;
      const dtFactor = Math.min(dt*60, 2);

      // look
      camera.rotation.set(pitch,yaw,0,"YXZ");

      // move (Shift = sprint; no Ctrl conflicts)
      const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).multiplyScalar(-1).normalize();
      const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
      let speed = keys.has("shift") ? SPRINT : WALK;
      if(keys.has("w")) player.vel.addScaledVector(forward,  speed);
      if(keys.has("s")) player.vel.addScaledVector(forward, -speed);
      if(keys.has("a")) player.vel.addScaledVector(right,   -speed);
      if(keys.has("d")) player.vel.addScaledVector(right,    speed);
      if(keys.has(" ") && player.grounded) player.vel.y = JUMP_VEL;

      // gravity + physics
      player.vel.y += GRAVITY * dtFactor;
      moveAndCollide(dtFactor);
      player.vel.x *= 0.91; player.vel.z *= 0.91;

      camera.position.copy(player.pos).add(new THREE.Vector3(0, player.size.y*0.4, 0));

      // ensure grid & build limited chunks per frame
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for(let i=0;i<BUILDS_PER_FRAME && buildQueue.length;i++){
        buildMesh(buildQueue.shift());
      }

      info.textContent = `Pos ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)} | grounded:${player.grounded} | queue:${buildQueue.length}`;
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
