<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Voxel Prototype (Textured)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1220; overflow:hidden; }
    #hud {
      position: fixed; top: 12px; left: 12px;
      font: 14px ui-monospace, Consolas, monospace; color: #e9eefc;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 10px;
      user-select: none; max-height: 95vh; overflow-y: auto; width: max-content;
    }
    #hud input[type=range]{ width: 140px; vertical-align: middle; margin: 4px 6px; }
    #cross { position: fixed; top: 50%; left: 50%; width: 18px; height: 18px; margin: -9px 0 0 -9px; pointer-events: none; }
    #cross:before, #cross:after { content: ""; position: absolute; background: #e9eefc; }
    #cross:before { left: 8px; top: 0; width: 2px; height: 18px; }
    #cross:after  { top: 8px; left: 0; height: 2px; width: 18px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Voxel Prototype</b> — click to lock mouse • F3 toggles HUD</div>
    <div>WASD move • Space jump • Shift sprint • Left: break • Right: place • 1–4 block • R: regen</div>
    <div id="info"></div>

    <hr>
    <b>Movement</b><br>
    Gravity <input id="gSlider" type="range" min="-0.1" max="0" step="0.001" value="-0.003"> <span id="gVal"></span><br>
    JumpVel <input id="jSlider" type="range" min="0" max="1.0" step="0.01" value="0.39"> <span id="jVal"></span><br>
    WalkSpd <input id="wSlider" type="range" min="0" max="0.2" step="0.001" value="0.072"> <span id="wVal"></span><br>
    SprintSpd <input id="sSlider" type="range" min="0" max="0.2" step="0.001" value="0.093"> <span id="sVal"></span><br>

    <hr>
    <b>Render</b><br>
    RenderDist <input id="rSlider" type="range" min="0" max="10" step="1" value="6"> <span id="rVal"></span><br>
    Builds/frame <input id="bSlider" type="range" min="1" max="24" step="1" value="6"> <span id="bVal"></span><br>

    <hr>
    <b>Biome / Shape</b><br>
    BiomeScale <input id="biomeSlider" type="range" min="0.0005" max="0.02" step="0.0001" value="0.0100"> <span id="biomeVal"></span><br>
    WarpScale <input id="warpScaleSlider" type="range" min="0.005" max="0.05" step="0.001" value="0.012"> <span id="warpScaleVal"></span><br>
    WarpStrength <input id="warpStrengthSlider" type="range" min="0" max="50" step="1" value="18"> <span id="warpStrengthVal"></span><br>

    PlainsBase <input id="plainsBaseSlider" type="range" min="0" max="140" step="1" value="33"> <span id="plainsBaseVal"></span><br>
    PlainsWobble <input id="plainsWobbleSlider" type="range" min="0" max="10" step="0.1" value="3.0"> <span id="plainsWobbleVal"></span><br>

    HillsScale <input id="hillsScaleSlider" type="range" min="0.005" max="0.05" step="0.001" value="0.015"> <span id="hillsScaleVal"></span><br>
    HillsAmp <input id="hillsAmpSlider" type="range" min="0" max="60" step="1" value="20"> <span id="hillsAmpVal"></span><br>

    MountScale <input id="mountScaleSlider" type="range" min="0.003" max="0.05" step="0.001" value="0.005"> <span id="mountScaleVal"></span><br>
    MountRidges <input id="mountRidgesSlider" type="range" min="10" max="300" step="1" value="220"> <span id="mountRidgesVal"></span><br>

    SpotScale <input id="spotScaleSlider" type="range" min="0.005" max="0.05" step="0.001" value="0.012"> <span id="spotScaleVal"></span><br>
    SpotThreshold <input id="spotThresholdSlider" type="range" min="0" max="1" step="0.01" value="0.55"> <span id="spotThresholdVal"></span><br>
    SpotAmp <input id="spotAmpSlider" type="range" min="0" max="60" step="1" value="30"> <span id="spotAmpVal"></span><br>
  </div>

  <div id="cross"></div>
<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  /* ===== Tunables (sliders override) ===== */
  let GRAVITY  = -0.003;
  let JUMP_VEL =  0.39;
  let WALK     =  0.072;
  let SPRINT   =  0.093;

  // friction
  let FRICTION_GROUND = 0.86;
  let FRICTION_AIR    = 0.93;

  // --- Biome & shape tuning ---
  let BIOME_SCALE     = 0.0100;
  let WARP_SCALE      = 0.012;
  let WARP_STRENGTH   = 18.0;

  // Plains
  let PLAINS_BASE     = 33;
  let PLAINS_WOBBLE   = 3.0;

  // Hills
  let HILLS_SCALE     = 0.015;
  let HILLS_AMP       = 20;

  // Mountains (ridged)
  let MOUNT_SCALE     = 0.005;
  let MOUNT_RIDGES    = 220;

  // “Hilly patches”
  let SPOT_SCALE      = 0.012;
  let SPOT_THRESHOLD  = 0.55;
  let SPOT_AMPLITUDE  = 30;

  // World management
  let GRID_RADIUS = 6;
  let BUILDS_PER_FRAME = 6;

  // backup shaping (unused in terrain formula but kept for sliders)
  let MASK_SCALE   = 0.001;
  let HILL_SCALE   = 0.020;
  let DETAIL_SCALE = 0.080;
  let MOUNT_AMP    = 5;

  /* ===== Config ===== */
  const CHUNK = { X:16, Y:256, Z:16 };
  const BLOCK = { AIR:0, STONE:1, GRASS:2, DIRT:3, GLASS:4 };
  let CURRENT_BLOCK = BLOCK.STONE;

  /* ===== Scene ===== */
  const scene = new THREE.Scene();
  // Create a vertical gradient canvas
  function makeSkyGradient(top="#87CEEB", bottom="#FFFFFF") {
    const size = 512;
    const canvas = document.createElement("canvas");
    canvas.width = 1; canvas.height = size;
    const ctx = canvas.getContext("2d");
    const grad = ctx.createLinearGradient(0,0,0,size);
    grad.addColorStop(0, top);
    grad.addColorStop(1, bottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,1,size);
    return new THREE.CanvasTexture(canvas);
  }
  
  scene.background = makeSkyGradient("#87CEEB", "#FFFFFF"); // light blue → white
  
  scene.fog = new THREE.Fog(0x0b1220, 80, 600);
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 3000);
  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(devicePixelRatio);
  if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.HemisphereLight(0xcfe8ff, 0x1a2438, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(0.7,1,0.4); scene.add(dir);

  const info = document.getElementById("info");

  /* ===== Texture atlas (PATCHED) =====
     Put atlas.png in the SAME folder as index.html.
     Prefer power-of-two size (e.g. 64x64, 128x128, 256x256).
     Our UVs treat (0,0) as TOP-LEFT, so we disable flipY.
  */
  const atlas = new THREE.TextureLoader().load(
    "atlas.png",
    () => console.log("[atlas] loaded", atlas.image?.width, "x", atlas.image?.height),
    undefined,
    (err) => console.error("[atlas] FAILED to load", err)
  );

  // Critical for top-left UVs:
  atlas.flipY = false;

  // Pixel-art friendly filtering:
  const isPOT = (n)=> (n & (n-1)) === 0;
  const w = ()=> atlas.image?.width|0, h = ()=> atlas.image?.height|0;

  atlas.magFilter = THREE.NearestFilter;
  atlas.minFilter = (atlas.image && isPOT(w()) && isPOT(h()))
    ? THREE.NearestMipMapNearestFilter
    : THREE.NearestFilter;

  atlas.wrapS = THREE.ClampToEdgeWrapping;
  atlas.wrapT = THREE.ClampToEdgeWrapping;
  if (atlas.colorSpace !== undefined) atlas.colorSpace = THREE.SRGBColorSpace;

  // Start with unlit material to rule out lighting issues.
  // You can toggle back to Lambert with "T".
  let CHUNK_MAT = new THREE.MeshBasicMaterial({ map: atlas });

  // Later (after chunks exist), press "T" to toggle Basic <-> Lambert for debugging
  let useBasic = true;
  addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "t") {
      useBasic = !useBasic;
      const mat = useBasic
        ? new THREE.MeshBasicMaterial({ map: atlas })
        : new THREE.MeshLambertMaterial({ map: atlas, fog: true, alphaTest: 0.5, depthWrite: true });
      // 'chunks' will be defined later in your file — this will work at runtime.
      for (const [,ch] of (window.chunks ?? [])) if (ch.mesh) ch.mesh.material = mat;
      CHUNK_MAT = mat; // so future meshes use the current material
      console.log("[mat] now using", useBasic ? "MeshBasicMaterial" : "MeshLambertMaterial");
    }
  });

  // If your atlas is a 4×4 tile grid (like the starter), set these:
  const TILES_X = 4, TILES_Y = 4;

  // Small half-pixel inset to avoid bleeding between tiles
  function tileUV(tx, ty){
    const su = 1 / TILES_X, sv = 1 / TILES_Y;
    const safeW = (atlas.image?.width  || 1024);
    const safeH = (atlas.image?.height || 1024);
    const insetU = 0.5 / safeW;
    const insetV = 0.5 / safeH;
    const u0 = tx*su + insetU, v0 = ty*sv + insetV;
    const u1 = (tx+1)*su - insetU, v1 = (ty+1)*sv - insetV;
    return { u0, v0, u1, v1 };
  }

  // Pick the correct cells for your PNG.
  // (Assuming row 0 has stone/grass/dirt/glass)
  const UV_TILES = {
    STONE:      tileUV(0,0),
    GRASS_TOP:  tileUV(2,0),
    GRASS_SIDE: tileUV(3,0),
    DIRT:       tileUV(1,0),
    GLASS:      tileUV(0,1) // <-- change if your glass is elsewhere
  };

  // Map block → per-face tiles (grass uses top/side/bottom)
  function uvFor(blockId, faceDir){
    if (blockId === BLOCK.STONE) return UV_TILES.STONE;
    if (blockId === BLOCK.DIRT)  return UV_TILES.DIRT;
    if (blockId === BLOCK.GLASS) return UV_TILES.GLASS;
    if (blockId === BLOCK.GRASS){
      if (faceDir === 2) return UV_TILES.GRASS_TOP;  // +Y
      if (faceDir === 3) return UV_TILES.DIRT;       // -Y
      return UV_TILES.GRASS_SIDE;                    // sides
    }
    return UV_TILES.STONE;
  }

  /* ===== keep the rest of YOUR original code below this line ===== */

    /* ===== Input ===== */
    const keys = new Set();
    let pointerLocked = false;
    let yaw = 0, pitch = 0;
    let hudVisible = true;

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
    document.body.addEventListener("click", () => {
      if (!pointerLocked) renderer.domElement.requestPointerLock();
    });
    document.addEventListener("pointerlockchange", () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
    });
    document.addEventListener("mousemove", (e) => {
      if (!pointerLocked) return;
      const sens = 0.0025, MAX_D = 80;
      const dx = Math.max(-MAX_D, Math.min(MAX_D, e.movementX||0));
      const dy = Math.max(-MAX_D, Math.min(MAX_D, e.movementY||0));
      yaw   -= dx * sens;
      pitch -= dy * sens;
      pitch = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001, pitch));
    });
    addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys.add(k);

      if (k === "f3") {
        hudVisible = !hudVisible;
        document.getElementById("hud").style.display = hudVisible ? "block" : "none";
        e.preventDefault(); e.stopPropagation();
        return;
      }

      if (k==="1") CURRENT_BLOCK=BLOCK.STONE;
      if (k==="2") CURRENT_BLOCK=BLOCK.GRASS;
      if (k==="3") CURRENT_BLOCK=BLOCK.DIRT;
      if (k==="4") CURRENT_BLOCK=BLOCK.GLASS;
      if (k==="r") regenAll();
    });
    addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
    addEventListener("contextmenu", (e) => e.preventDefault());

    /* ===== Slider bindings ===== */
    const bind = (id, setter, fmt=(v)=>v)=> {
      const el = document.getElementById(id);
      const out = document.getElementById(id.replace("Slider","Val"));
      const sync = ()=> { if(out) out.textContent = fmt(el.value); };
      el.addEventListener("input", (e)=>{ setter(parseFloat(e.target.value)); regenAll(); sync(); });
      sync();
    };
    bind("gSlider",   v => GRAVITY=v);
    bind("jSlider",   v => JUMP_VEL=v);
    bind("wSlider",   v => WALK=v);
    bind("sSlider",   v => SPRINT=v);
    bind("rSlider",   v => { GRID_RADIUS = v|0; scheduleGridRefresh(); }, v=>v|0);
    bind("bSlider",   v => { BUILDS_PER_FRAME = v|0; }, v=>v|0);
    bind("biomeSlider",     v => { BIOME_SCALE = v; }, v=> (+v).toFixed(4));
    bind("warpScaleSlider", v => { WARP_SCALE = v; }, v=> (+v).toFixed(3));
    bind("warpStrengthSlider", v => { WARP_STRENGTH = v; }, v=> v|0);
    bind("plainsBaseSlider",   v => { PLAINS_BASE = v; }, v=> v|0);
    bind("plainsWobbleSlider", v => { PLAINS_WOBBLE = v; }, v=> (+v).toFixed(1));
    bind("hillsScaleSlider", v => { HILLS_SCALE = v; }, v=> (+v).toFixed(3));
    bind("hillsAmpSlider",   v => { HILLS_AMP = v; }, v=> v|0);
    bind("mountScaleSlider",  v => { MOUNT_SCALE = v; }, v=> (+v).toFixed(3));
    bind("mountRidgesSlider", v => { MOUNT_RIDGES = v; }, v=> v|0);
    bind("spotScaleSlider",     v => { SPOT_SCALE = v; }, v=> (+v).toFixed(3));
    bind("spotThresholdSlider", v => { SPOT_THRESHOLD = v; }, v=> (+v).toFixed(2));
    bind("spotAmpSlider",       v => { SPOT_AMPLITUDE = v; }, v=> v|0);

    /* ===== Noise ===== */
    function hash2i(x, y) {
      let h = x*374761393 + y*668265263;
      h = (h ^ (h>>13)) * 1274126177;
      return (h>>>0)/0xffffffff;
    }
    const smoothstep = t => t*t*(3-2*t);
    function valueNoise2(x,y){
      const xi=Math.floor(x), yi=Math.floor(y);
      const tx=x-xi, ty=y-yi;
      const a=hash2i(xi,yi), b=hash2i(xi+1,yi), c=hash2i(xi,yi+1), d=hash2i(xi+1,yi+1);
      const sx=smoothstep(tx), sy=smoothstep(ty);
      const u=a+(b-a)*sx, v=c+(d-c)*sx;
      return u+(v-u)*sy;
    }
    function fbm2(x,y){
      let amp=1,freq=1,sum=0,norm=0;
      for(let i=0;i<4;i++){
        sum+=valueNoise2(x*freq,y*freq)*amp;
        norm+=amp; amp*=0.5; freq*=2;
      }
      return sum/norm;
    }
    function ridged(x, y, octaves=4){
      let amp=1, freq=1, sum=0, norm=0;
      for(let i=0;i<octaves;i++){
        const r = 1.0 - Math.abs(0.5 - fbm2(x*freq, y*freq)) * 2.0;
        sum += r * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm;
    }
    function warp2(x, y){
      const wx = fbm2(x*WARP_SCALE*2.13, y*WARP_SCALE*0.91);
      const wy = fbm2(x*WARP_SCALE*1.31, y*WARP_SCALE*1.73);
      return { x: x + (wx-0.5)*2*WARP_STRENGTH, y: y + (wy-0.5)*2*WARP_STRENGTH };
    }
    function sstep(a,b,t){ const u=Math.max(0,Math.min(1,(t-a)/(b-a))); return u*u*(3-2*u); }
    function sampleTerrain(wx, wz) {
      const w = warp2(wx, wz); const x = w.x, y = w.y;
      const biomeN = fbm2(x*BIOME_SCALE, y*BIOME_SCALE);
      const tPlains    = sstep(0.00, 0.35, biomeN);
      const tHills     = sstep(0.30, 0.65, biomeN);
      const tMountains = sstep(0.55, 0.95, biomeN);
      const wSum = tPlains + tHills + tMountains + 1e-6;
      const bP = tPlains/wSum, bH=tHills/wSum, bM=tMountains/wSum;
      const plains = PLAINS_BASE + (fbm2(x*0.03, y*0.03)-0.5)*2*PLAINS_WOBBLE;
      const hills  = PLAINS_BASE + 3 + fbm2(x*HILLS_SCALE, y*HILLS_SCALE)*HILLS_AMP;
      const mountains = PLAINS_BASE + 6 + ridged(x*MOUNT_SCALE, y*MOUNT_SCALE)*MOUNT_RIDGES;
      let h = bP*plains + bH*hills + bM*mountains;
      const spot = fbm2(x*SPOT_SCALE, y*SPOT_SCALE);
      if (spot > SPOT_THRESHOLD){
        const k = (spot - SPOT_THRESHOLD) / (1 - SPOT_THRESHOLD);
        const spotWeight = bP*1.0 + bH*0.6;
        h += k * SPOT_AMPLITUDE * spotWeight;
      }
      return Math.floor(h);
    }
    const FLAT_WORLD_Y = null;

    /* ===== World ===== */
    class Chunk {
      constructor(cx,cz){
        this.cx=cx; this.cz=cz;
        this.blocks=new Uint8Array(CHUNK.X*CHUNK.Y*CHUNK.Z);
        this.mesh=null;
        this.generated=false;
        this.dirty=false;
      }
    }
    const chunks = new Map();
    const buildQueue = [];
    const key = (cx,cz)=>`${cx},${cz}`;
    const idx = (x,y,z)=> x + CHUNK.X*(z + CHUNK.Z*y);

    function generateChunk(c){
      if(c.generated) return;
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
      for(let z=0;z<CHUNK.Z;z++){
        for(let x=0;x<CHUNK.X;x++){
          const wx=baseX+x, wz=baseZ+z;
          const hRaw = FLAT_WORLD_Y ?? sampleTerrain(wx,wz);
          const h = Math.max(1, Math.min(CHUNK.Y - 2, hRaw));
          for(let y=0;y<CHUNK.Y;y++){
            let id=BLOCK.AIR;
            if(y===h) id=BLOCK.GRASS;
            else if(y<h-3) id=BLOCK.STONE;
            else if(y<h) id=BLOCK.DIRT;
            c.blocks[idx(x,y,z)]=id;
          }
        }
      }
      c.generated=true;
      c.dirty=true;
      enqueueBuild(c);
      markNeighborsDirty(c.cx, c.cz); // keep borders fresh
    }

    function shouldDrawFace(cur, neighbor){
      if (neighbor === BLOCK.AIR) return true;
      if (neighbor === BLOCK.GLASS && cur !== BLOCK.GLASS) return true;
      return false;
    }

    function neighborBlock(c,x,y,z,dir){
      let nx=x,ny=y,nz=z,cx=c.cx,cz=c.cz;
      if(dir===0)nx++; if(dir===1)nx--;
      if(dir===2)ny++; if(dir===3)ny--;
      if(dir===4)nz++; if(dir===5)nz--;
      if(ny<0||ny>=CHUNK.Y) return BLOCK.AIR;
      if(nx<0){cx--;nx+=CHUNK.X;}
      if(nx>=CHUNK.X){cx++;nx-=CHUNK.X;}
      if(nz<0){cz--;nz+=CHUNK.Z;}
      if(nz>=CHUNK.Z){cz++;nz-=CHUNK.Z;}
      const nc=chunks.get(key(cx,cz));
      if(!nc||!nc.generated) return BLOCK.AIR;
      return nc.blocks[idx(nx,ny,nz)];
    }

    function enqueueBuild(ch){ if (!buildQueue.includes(ch)) buildQueue.push(ch); }
    function buildMesh(c){
      if (!c.dirty) return;
      c.dirty = false;
      if(c.mesh){
        scene.remove(c.mesh);
        c.mesh.geometry.dispose();
        c.mesh.material.dispose?.();
        c.mesh = null;
      }
    
      const pos=[], norm=[], uv=[];
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
    
      // Push triangle with UVs (rect is {u0,v0,u1,v1})
      const pushTri=(a,b,cpt,n,rect)=>{
        pos.push(a.x,a.y,a.z, b.x,b.y,b.z, cpt.x,cpt.y,cpt.z);
        norm.push(n.x,n.y,n.z, n.x,n.y,n.z, n.x,n.y,n.z);
        // CCW winding: map quad → two tris
        // tri1 verts: a(0,0), b(1,0), c(1,1)
        uv.push(rect.u0,rect.v0,  rect.u1,rect.v0,  rect.u1,rect.v1);
      };
      const pushQuad=(p0,p1,p2,p3,n,rect)=>{
        // tri 1: p0,p1,p2  | tri 2: p0,p2,p3
        pushTri(p0,p1,p2,n,rect);
        // tri2 uses (0,0)->p0, (1,1)->p2, (0,1)->p3
        pos.push(p0.x,p0.y,p0.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z);
        norm.push(n.x,n.y,n.z,   n.x,n.y,n.z,   n.x,n.y,n.z);
        uv.push(rect.u0,rect.v0, rect.u1,rect.v1, rect.u0,rect.v1);
      };
    
      const addFace=(x,y,z,dir,blockId)=>{
        const bx=baseX+x, by=y, bz=baseZ+z;
        const rect = uvFor(blockId, dir);
        switch(dir){
          case 0: // +X
            pushQuad(
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(1,0,0), rect); break;
          case 1: // -X
            pushQuad(
              new THREE.Vector3(bx,by,  bz+1),
              new THREE.Vector3(bx,by+1,bz+1),
              new THREE.Vector3(bx,by+1,bz),
              new THREE.Vector3(bx,by,  bz),
              new THREE.Vector3(-1,0,0), rect); break;
          case 2: // +Y (top)
            pushQuad(
              new THREE.Vector3(bx,  by+1,bz),
              new THREE.Vector3(bx,  by+1,bz+1),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(0,1,0), rect); break;
          case 3: // -Y (bottom)
            pushQuad(
              new THREE.Vector3(bx,  by,  bz+1),
              new THREE.Vector3(bx,  by,  bz),
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(0,-1,0), rect); break;
          case 4: // +Z
            pushQuad(
              new THREE.Vector3(bx+1,by,  bz+1),
              new THREE.Vector3(bx+1,by+1,bz+1),
              new THREE.Vector3(bx,  by+1,bz+1),
              new THREE.Vector3(bx,  by,  bz+1),
              new THREE.Vector3(0,0,1), rect); break;
          case 5: // -Z
            pushQuad(
              new THREE.Vector3(bx,  by,  bz),
              new THREE.Vector3(bx,  by+1,bz),
              new THREE.Vector3(bx+1,by+1,bz),
              new THREE.Vector3(bx+1,by,  bz),
              new THREE.Vector3(0,0,-1), rect); break;
        }
      };
    
      for(let y=0;y<CHUNK.Y;y++){
        for(let z=0;z<CHUNK.Z;z++){
          for(let x=0;x<CHUNK.X;x++){
            const id=c.blocks[idx(x,y,z)];
            if(id===BLOCK.AIR) continue;
            for(let d=0;d<6;d++){
              const nb=neighborBlock(c,x,y,z,d);
              if (shouldDrawFace(id, nb)) addFace(x,y,z,d,id);
            }
          }
        }
      }
    
      const geom=new THREE.BufferGeometry();
      geom.setAttribute("position",new THREE.Float32BufferAttribute(pos,3));
      geom.setAttribute("normal",new THREE.Float32BufferAttribute(norm,3));
      geom.setAttribute("uv",new THREE.Float32BufferAttribute(uv,2));
      geom.computeBoundingSphere();
    
      c.mesh=new THREE.Mesh(geom, CHUNK_MAT);
      scene.add(c.mesh);
    }


    /* ===== World management ===== */
    let lastChunkX = Infinity, lastChunkZ = Infinity;
    function ensureChunk(cx,cz){
      const k = key(cx,cz);
      let ch = chunks.get(k);
      if(!ch){ ch=new Chunk(cx,cz); chunks.set(k,ch); }
      if(!ch.generated) generateChunk(ch);
      return ch;
    }
    function scheduleGridRefresh(){ lastChunkX = Infinity; lastChunkZ = Infinity; }
    function updateVisibleGridIfNeeded(wx,wz){
      const pcx=Math.floor(wx/CHUNK.X), pcz=Math.floor(wz/CHUNK.Z);
      if (pcx === lastChunkX && pcz === lastChunkZ) return;
      lastChunkX = pcx; lastChunkZ = pcz;
      for(let dz=-GRID_RADIUS;dz<=GRID_RADIUS;dz++){
        for(let dx=-GRID_RADIUS;dx<=GRID_RADIUS;dx++){
          const ch = ensureChunk(pcx+dx, pcz+dz);
          if (ch.dirty) enqueueBuild(ch);
        }
      }
    }
    function markNeighborsDirty(cx, cz){
      const offsets = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dx,dz] of offsets){
        const nb = chunks.get(key(cx+dx, cz+dz));
        if (nb && nb.generated){ nb.dirty = true; enqueueBuild(nb); }
      }
    }
    function regenAll(){
      for(const [,ch] of chunks){
        if(ch.mesh){ scene.remove(ch.mesh); ch.mesh.geometry.dispose(); ch.mesh.material && ch.mesh.material.dispose?.(); }
      }
      chunks.clear();
      buildQueue.length = 0;
      scheduleGridRefresh();
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for(const [,ch] of chunks){ ch.dirty = true; enqueueBuild(ch); }
    }

    /* ===== Block Editing ===== */
    function getBlock(wx,wy,wz){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return BLOCK.AIR;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return BLOCK.AIR;
      return ch.blocks[idx(lx,ly,lz)];
    }
    function setBlock(wx,wy,wz,id){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return;

      const i = idx(lx,ly,lz);
      if (ch.blocks[i] === id) return;
      ch.blocks[i]=id;
      ch.dirty = true; enqueueBuild(ch);

      const mark = (nx,nz)=>{
        const nb = chunks.get(key(nx,nz));
        if (nb && nb.generated) { nb.dirty = true; enqueueBuild(nb); }
      };
      if (lx === 0)           mark(cx-1, cz);
      if (lx === CHUNK.X-1)   mark(cx+1, cz);
      if (lz === 0)           mark(cx, cz-1);
      if (lz === CHUNK.Z-1)   mark(cx, cz+1);
    }

    /* ===== Player & Picking & Physics ===== */
    const player = {
      pos: new THREE.Vector3(8, 80, 8),
      vel: new THREE.Vector3(),
      size: new THREE.Vector3(0.6, 1.8, 0.6),
      grounded: false
    };
    function eyePos(){ return player.pos.clone().add(new THREE.Vector3(0, player.size.y*0.75, 0)); }
    function pick(maxDist=8){
      const dir=new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch,yaw,0,"YXZ"));
      const pos=eyePos(); const step=0.1; let lastAir=pos.clone();
      for(let i=0;i<maxDist/step;i++){
        const b=getBlock(Math.floor(pos.x),Math.floor(pos.y),Math.floor(pos.z));
        if(b!==BLOCK.AIR) return {hit:true,pos:pos.clone().floor(),place:lastAir.clone().floor()};
        lastAir.copy(pos); pos.addScaledVector(dir,step);
      } return {hit:false};
    }
    addEventListener("mousedown",(e)=>{
      if(!pointerLocked) return;
      const p=pick(10); if(!p.hit) return;
      if(e.button===0) setBlock(p.pos.x,p.pos.y,p.pos.z,BLOCK.AIR);
      if(e.button===2) setBlock(p.place.x,p.place.y,p.place.z,CURRENT_BLOCK);
    });

    const EPS = 0.001;
    function eachCollidingBlock(pos, size, cb){
      const half = size.clone().multiplyScalar(0.5);
      const pMin = pos.clone().sub(half);
      const pMax = pos.clone().add(half);
      const minX=Math.floor(pMin.x), maxX=Math.floor(pMax.x);
      const minY=Math.floor(pMin.y), maxY=Math.floor(pMax.y);
      const minZ=Math.floor(pMin.z), maxZ=Math.floor(pMax.z);
      for(let x=minX;x<=maxX;x++){
        for(let y=minY;y<=maxY;y++){
          for(let z=minZ;z<=maxZ;z++){
            if(getBlock(x,y,z)!==BLOCK.AIR){
              cb(new THREE.Vector3(x,y,z), new THREE.Vector3(x+1,y+1,z+1));
            }
          }
        }
      }
    }
    function moveAndCollide(dtFactor){
      player.grounded=false;

      // Y
      player.pos.y += player.vel.y * dtFactor;
      const halfY = player.size.y * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinY=player.pos.y-halfY, pMaxY=player.pos.y+halfY;
        if (player.vel.y > 0 && pMinY < bMax.y && pMaxY > bMin.y){
          player.pos.y = bMin.y - halfY - EPS; player.vel.y = 0;
        }
        if (player.vel.y < 0 && pMaxY > bMin.y && pMinY < bMax.y){
          player.pos.y = bMax.y + halfY + EPS; player.vel.y = 0; player.grounded = true;
        }
      });

      // X
      player.pos.x += player.vel.x * dtFactor;
      const halfX = player.size.x * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinX=player.pos.x-halfX, pMaxX=player.pos.x+halfX;
        if (player.vel.x > 0 && pMaxX > bMin.x && pMinX < bMax.x){
          player.pos.x = bMin.x - halfX - EPS; player.vel.x = 0;
        } else if (player.vel.x < 0 && pMinX < bMax.x && pMaxX > bMin.x){
          player.pos.x = bMax.x + halfX + EPS; player.vel.x = 0;
        }
      });

      // Z
      player.pos.z += player.vel.z * dtFactor;
      const halfZ = player.size.z * 0.5;
      eachCollidingBlock(player.pos,player.size,(bMin,bMax)=>{
        const pMinZ=player.pos.z-halfZ, pMaxZ=player.pos.z+halfZ;
        if (player.vel.z > 0 && pMaxZ > bMin.z && pMinZ < bMax.z){
          player.pos.z = bMin.z - halfZ - EPS; player.vel.z = 0;
        } else if (player.vel.z < 0 && pMinZ < bMax.z && pMaxZ > bMin.z){
          player.pos.z = bMax.z + halfZ + EPS; player.vel.z = 0;
        }
      });
    }

    function scheduleFriction(dtFactor){
      const f = player.grounded ? FRICTION_GROUND : FRICTION_AIR;
      const k = Math.pow(f, dtFactor);
      player.vel.x *= k; player.vel.z *= k;
    }

    /* ===== Startup & Loop ===== */
    regenAll();

    let last = performance.now();
    function animate(now){
      const dt=(now-last)/1000; last=now;
      const dtFactor = Math.min(dt*60, 2);

      // look
      camera.rotation.set(pitch,yaw,0,"YXZ");

      // move
      const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).multiplyScalar(-1).normalize();
      const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
      let speed = keys.has("shift") ? SPRINT : WALK;
      if(keys.has("w")) player.vel.addScaledVector(forward,  speed);
      if(keys.has("s")) player.vel.addScaledVector(forward, -speed);
      if(keys.has("a")) player.vel.addScaledVector(right,   -speed);
      if(keys.has("d")) player.vel.addScaledVector(right,    speed);
      if(keys.has(" ") && player.grounded) player.vel.y = JUMP_VEL;

      // physics
      player.vel.y += GRAVITY * dtFactor;
      moveAndCollide(dtFactor);
      scheduleFriction(dtFactor);

      camera.position.copy(player.pos).add(new THREE.Vector3(0, player.size.y*0.4, 0));

      // chunk loading & meshing
      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for(let i=0;i<BUILDS_PER_FRAME && buildQueue.length;i++){
        buildMesh(buildQueue.shift());
      }

      info.textContent = `Pos ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)} | grounded:${player.grounded} | queue:${buildQueue.length}`;
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
