<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Voxel Prototype (Textured)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1220; overflow:hidden; }
    #hud {
      position: fixed; top: 12px; left: 12px;
      font: 14px ui-monospace, Consolas, monospace; color: #e9eefc;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 10px;
      user-select: none; max-height: 95vh; overflow-y: auto; width: max-content;
    }
    #hud input[type=range]{ width: 140px; vertical-align: middle; margin: 4px 6px; }
    #cross { position: fixed; top: 50%; left: 50%; width: 18px; height: 18px; margin: -9px 0 0 -9px; pointer-events: none; }
    #cross:before, #cross:after { content: ""; position: absolute; background: #e9eefc; }
    #cross:before { left: 8px; top: 0; width: 2px; height: 18px; }
    #cross:after  { top: 8px; left: 0; height: 2px; width: 18px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Voxel Prototype</b> — click to lock mouse • F3 toggles HUD</div>
    <div>WASD move • Space jump • Shift sprint • Left: break • Right: place • 1–4 block • R: regen</div>
    <div id="info"></div>
    <!-- sliders omitted for brevity -->
  </div>
  <div id="cross"></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ===== Tunables (sliders override) ===== */
let GRAVITY  = -0.003;
let JUMP_VEL =  0.39;
let WALK     =  0.072;
let SPRINT   =  0.093;

// friction
let FRICTION_GROUND = 0.86;
let FRICTION_AIR    = 0.93;

// --- Biome & shape tuning ---
let BIOME_SCALE     = 0.0100;
let WARP_SCALE      = 0.012;
let WARP_STRENGTH   = 18.0;
let PLAINS_BASE     = 33;
let PLAINS_WOBBLE   = 3.0;
let HILLS_SCALE     = 0.015;
let HILLS_AMP       = 20;
let MOUNT_SCALE     = 0.005;
let MOUNT_RIDGES    = 220;
let SPOT_SCALE      = 0.012;
let SPOT_THRESHOLD  = 0.55;
let SPOT_AMPLITUDE  = 30;

// World management
let GRID_RADIUS = 6;
let BUILDS_PER_FRAME = 6;

/* ===== Config ===== */
const CHUNK = { X:16, Y:256, Z:16 };
const BLOCK = { AIR:0, STONE:1, GRASS:2, DIRT:3, GLASS:4 };
let CURRENT_BLOCK = BLOCK.STONE;

/* ===== Scene ===== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 3000);
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// Background gradient + fog
function makeSkyGradient(top="#87CEEB", bottom="#FFFFFF") {
  const size = 512;
  const canvas = document.createElement("canvas");
  canvas.width = 1; canvas.height = size;
  const ctx = canvas.getContext("2d");
  const g = ctx.createLinearGradient(0,0,0,size);
  g.addColorStop(0, top);
  g.addColorStop(1, bottom);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,1,size);
  return new THREE.CanvasTexture(canvas);
}
scene.background = makeSkyGradient("#87CEEB", "#FFFFFF");
scene.fog = new THREE.Fog(0x87CEEB, 80, 600);

// Lights
scene.add(new THREE.HemisphereLight(0xcfe8ff, 0x1a2438, 0.9));
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(0.7,1,0.4); scene.add(dir);

const info = document.getElementById("info");

/* ===== Texture atlas ===== */
const atlas = new THREE.TextureLoader().load("atlas.png",
  () => console.log("[atlas] loaded", atlas.image?.width, "x", atlas.image?.height),
  undefined,
  (err) => console.error("[atlas] FAILED to load", err)
);
atlas.flipY = false;
atlas.magFilter = THREE.NearestFilter;
atlas.minFilter = THREE.NearestFilter;
atlas.wrapS = THREE.ClampToEdgeWrapping;
atlas.wrapT = THREE.ClampToEdgeWrapping;
if (atlas.colorSpace !== undefined) atlas.colorSpace = THREE.SRGBColorSpace;

let CHUNK_MAT = new THREE.MeshBasicMaterial({ map: atlas });

const TILES_X = 4, TILES_Y = 4;
function tileUV(tx, ty){
  const su = 1 / TILES_X, sv = 1 / TILES_Y;
  return { u0: tx*su, v0: ty*sv, u1: (tx+1)*su, v1: (ty+1)*sv };
}
const UV_TILES = {
  STONE:      tileUV(0,0),
  GRASS_TOP:  tileUV(2,0),
  GRASS_SIDE: tileUV(3,0),
  DIRT:       tileUV(1,0),
  GLASS:      tileUV(0,1)
};
function uvFor(blockId, faceDir){
  if (blockId === BLOCK.STONE) return UV_TILES.STONE;
  if (blockId === BLOCK.DIRT)  return UV_TILES.DIRT;
  if (blockId === BLOCK.GLASS) return UV_TILES.GLASS;
  if (blockId === BLOCK.GRASS){
    if (faceDir === 2) return UV_TILES.GRASS_TOP;
    if (faceDir === 3) return UV_TILES.DIRT;
    return UV_TILES.GRASS_SIDE;
  }
  return UV_TILES.STONE;
}

/* ===== World / Input / Physics / Build logic ===== */
// keep the rest of your world generation, input handling, chunk building,
// physics, and animation loop exactly as you had it.

</script>
</body>
</html>
