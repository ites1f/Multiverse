<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Voxel Prototype</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1220; overflow:hidden; }
    #hud {
      position:fixed; top:12px; left:12px;
      font:14px ui-monospace, Consolas, monospace; color:#e9eefc;
      background:rgba(0,0,0,.35); padding:8px 10px; border-radius:10px; user-select:none;
    }
    #cross { position:fixed; top:50%; left:50%; width:18px; height:18px; margin:-9px 0 0 -9px; pointer-events:none; }
    #cross:before, #cross:after { content:""; position:absolute; background:#e9eefc; }
    #cross:before { left:8px; top:0; width:2px; height:18px; }
    #cross:after { top:8px; left:0; height:2px; width:18px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Voxel Prototype</b> â€” click to lock mouse</div>
    <div>WASD move â€¢ Space jump â€¢ Shift sprint â€¢ Left: break â€¢ Right: place â€¢ 1â€“4 block â€¢ R: regen</div>
    <div id="info"></div>
  </div>
  <div id="cross"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /* ===== Config ===== */
    const CHUNK = { X:16, Y:64, Z:16 };
    const GRID_RADIUS = 3;
    const BLOCK = { AIR:0, STONE:1, GRASS:2, DIRT:3, GLASS:4 };
    let CURRENT_BLOCK = BLOCK.STONE;

    /* ===== Scene ===== */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);
    scene.fog = new THREE.Fog(0x0b1220, 80, 220);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xcfe8ff, 0x1a2438, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.7,1,0.4);
    scene.add(dir);

    const info = document.getElementById("info");
/* ===== Input ===== */
const keys = new Set();
let pointerLocked = false;
let yaw = 0, pitch = 0;

// ðŸ”¹ Moved eyePos + pick ABOVE input section so clicks work
function eyePos(){
  // eye ~75% up the player body
  return player.pos.clone().add(new THREE.Vector3(0, player.size.y * 0.75, 0));
}

function pick(maxDist=8){
  const dir = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch,yaw,0,"YXZ"));
  const pos = eyePos(); // ðŸ”¹ use player eye, not camera.position
  const step = 0.1;
  let lastAir = pos.clone();
  for(let i=0;i<maxDist/step;i++){
    const b = getBlock(Math.floor(pos.x),Math.floor(pos.y),Math.floor(pos.z));
    if(b!==BLOCK.AIR){
      return {hit:true,pos:pos.clone().floor(),place:lastAir.clone().floor()};
    }
    lastAir.copy(pos);
    pos.addScaledVector(dir,step);
  }
  return {hit:false};
}

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

document.body.addEventListener("click", () => {
  if (!pointerLocked) renderer.domElement.requestPointerLock();
});

document.addEventListener("pointerlockchange", () => {
  pointerLocked = (document.pointerLockElement === renderer.domElement);
});

document.addEventListener("mousemove", (e) => {
  if (!pointerLocked) return;
  const sens = 0.0025, MAX_D = 80;
  const dx = Math.max(-MAX_D, Math.min(MAX_D, e.movementX||0));
  const dy = Math.max(-MAX_D, Math.min(MAX_D, e.movementY||0));
  yaw   -= dx * sens;
  pitch -= dy * sens;
  const TWO_PI = Math.PI * 2;
  if (yaw >  Math.PI) yaw -= TWO_PI;
  if (yaw < -Math.PI) yaw += TWO_PI;
  pitch = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001, pitch));
});

addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  keys.add(k);
  if (k==="1") CURRENT_BLOCK=BLOCK.STONE;
  if (k==="2") CURRENT_BLOCK=BLOCK.GRASS;
  if (k==="3") CURRENT_BLOCK=BLOCK.DIRT;
  if (k==="4") CURRENT_BLOCK=BLOCK.GLASS;
  if (k==="r") regenAll();
});

addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

addEventListener("contextmenu", (e) => e.preventDefault());

// ðŸ”¹ Add mouse button handler back in
addEventListener("mousedown",(e)=>{
  if(!pointerLocked) return;
  const p = pick(10);
  if(!p.hit) return;
  if(e.button===0) setBlock(p.pos.x,p.pos.y,p.pos.z,BLOCK.AIR);          // break
  if(e.button===2) setBlock(p.place.x,p.place.y,p.place.z,CURRENT_BLOCK); // place
});

    /* ===== Noise ===== */
    function hash2i(x, y) {
      let h = x*374761393 + y*668265263;
      h = (h ^ (h>>13)) * 1274126177;
      return (h>>>0)/0xffffffff;
    }
    const smoothstep = t => t*t*(3-2*t);
    function valueNoise2(x,y){
      const xi=Math.floor(x), yi=Math.floor(y);
      const tx=x-xi, ty=y-yi;
      const a=hash2i(xi,yi);
      const b=hash2i(xi+1,yi);
      const c=hash2i(xi,yi+1);
      const d=hash2i(xi+1,yi+1);
      const sx=smoothstep(tx), sy=smoothstep(ty);
      const u=a+(b-a)*sx, v=c+(d-c)*sx;
      return u+(v-u)*sy;
    }
    function fbm2(x,y){
      let amp=1,freq=1,sum=0,norm=0;
      for(let i=0;i<4;i++){
        sum+=valueNoise2(x*freq,y*freq)*amp;
        norm+=amp; amp*=0.5; freq*=2;
      }
      return sum/norm;
    }

    /* ===== World ===== */
    class Chunk {
      constructor(cx,cz){
        this.cx=cx; this.cz=cz;
        this.blocks=new Uint8Array(CHUNK.X*CHUNK.Y*CHUNK.Z);
        this.mesh=null;
        this.generated=false;
        this.dirty=false;
      }
    }
    const chunks=new Map();
    const key = (cx,cz)=>`${cx},${cz}`;
    const idx = (x,y,z)=> x + CHUNK.X*(z + CHUNK.Z*y);

    const sampleTerrain = (wx,wz)=> Math.floor(24 + fbm2(wx*0.045,wz*0.045)*20);

    function generateChunk(c){
      if(c.generated) return;
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;
      for(let z=0;z<CHUNK.Z;z++){
        for(let x=0;x<CHUNK.X;x++){
          const wx=baseX+x, wz=baseZ+z;
          const h=sampleTerrain(wx,wz);
          for(let y=0;y<CHUNK.Y;y++){
            let id=BLOCK.AIR;
            if(y===h) id=BLOCK.GRASS;
            else if(y<h-3) id=BLOCK.STONE;
            else if(y<h) id=BLOCK.DIRT;
            c.blocks[idx(x,y,z)]=id;
          }
        }
      }
      c.generated=true;
      c.dirty=true;
    }

    function shouldDrawFace(cur, neighbor){
      if (neighbor === BLOCK.AIR) return true;
      if (neighbor === BLOCK.GLASS && cur !== BLOCK.GLASS) return true;
      return false;
    }

    function blockColor(id){
      switch(id){
        case BLOCK.STONE:return new THREE.Color(0x9aa0a6);
        case BLOCK.GRASS:return new THREE.Color(0x55aa55);
        case BLOCK.DIRT:return new THREE.Color(0x7a4e2a);
        case BLOCK.GLASS:return new THREE.Color(0x77c4ff);
      } return new THREE.Color(0,0,0);
    }

    function neighborBlock(c,x,y,z,dir){
      let nx=x,ny=y,nz=z,cx=c.cx,cz=c.cz;
      if(dir===0)nx++; if(dir===1)nx--;
      if(dir===2)ny++; if(dir===3)ny--;
      if(dir===4)nz++; if(dir===5)nz--;
      if(ny<0||ny>=CHUNK.Y) return BLOCK.AIR;
      if(nx<0){cx--;nx+=CHUNK.X;}
      if(nx>=CHUNK.X){cx++;nx-=CHUNK.X;}
      if(nz<0){cz--;nz+=CHUNK.Z;}
      if(nz>=CHUNK.Z){cz++;nz-=CHUNK.Z;}
      const nc=chunks.get(key(cx,cz));
      if(!nc||!nc.generated) return BLOCK.AIR;
      return nc.blocks[idx(nx,ny,nz)];
    }

    function buildMesh(c){
      if (!c.dirty) return;
      c.dirty = false;
      if(c.mesh){
        scene.remove(c.mesh);
        c.mesh.geometry.dispose();
        c.mesh.material.dispose();
        c.mesh = null;
      }
      const pos=[],norm=[],col=[];
      const baseX=c.cx*CHUNK.X, baseZ=c.cz*CHUNK.Z;

      const pushTri=(a,b,cpt,n,color)=>{
        pos.push(a.x,a.y,a.z, b.x,b.y,b.z, cpt.x,cpt.y,cpt.z);
        norm.push(n.x,n.y,n.z, n.x,n.y,n.z, n.x,n.y,n.z);
        for(let i=0;i<3;i++) col.push(color.r,color.g,color.b);
      };
      const pushQuad=(p0,p1,p2,p3,n,color)=>{ pushTri(p0,p1,p2,n,color); pushTri(p0,p2,p3,n,color); };

      const addFace=(x,y,z,dir,color)=>{
        const bx=baseX+x, by=y, bz=baseZ+z;
        switch(dir){
          case 0: pushQuad(
            new THREE.Vector3(bx+1,by,  bz  ),
            new THREE.Vector3(bx+1,by+1,bz  ),
            new THREE.Vector3(bx+1,by+1,bz+1),
            new THREE.Vector3(bx+1,by,  bz+1),
            new THREE.Vector3(1,0,0), color); break;
          case 1: pushQuad(
            new THREE.Vector3(bx,by,  bz+1),
            new THREE.Vector3(bx,by+1,bz+1),
            new THREE.Vector3(bx,by+1,bz  ),
            new THREE.Vector3(bx,by,  bz  ),
            new THREE.Vector3(-1,0,0), color); break;
          case 2: pushQuad(
            new THREE.Vector3(bx,  by+1,bz  ),
            new THREE.Vector3(bx,  by+1,bz+1),
            new THREE.Vector3(bx+1,by+1,bz+1),
            new THREE.Vector3(bx+1,by+1,bz  ),
            new THREE.Vector3(0,1,0), color); break;
          case 3: pushQuad(
            new THREE.Vector3(bx,  by,  bz+1),
            new THREE.Vector3(bx,  by,  bz  ),
            new THREE.Vector3(bx+1,by,  bz  ),
            new THREE.Vector3(bx+1,by,  bz+1),
            new THREE.Vector3(0,-1,0), color); break;
          case 4: pushQuad(
            new THREE.Vector3(bx+1,by,  bz+1),
            new THREE.Vector3(bx+1,by+1,bz+1),
            new THREE.Vector3(bx,  by+1,bz+1),
            new THREE.Vector3(bx,  by,  bz+1),
            new THREE.Vector3(0,0,1), color); break;
          case 5: pushQuad(
            new THREE.Vector3(bx,  by,  bz  ),
            new THREE.Vector3(bx,  by+1,bz  ),
            new THREE.Vector3(bx+1,by+1,bz  ),
            new THREE.Vector3(bx+1,by,  bz  ),
            new THREE.Vector3(0,0,-1), color); break;
        }
      };

      for(let y=0;y<CHUNK.Y;y++){
        for(let z=0;z<CHUNK.Z;z++){
          for(let x=0;x<CHUNK.X;x++){
            const id=c.blocks[idx(x,y,z)];
            if(id===BLOCK.AIR) continue;
            const color=blockColor(id);
            for(let d=0;d<6;d++){
              const nb=neighborBlock(c,x,y,z,d);
              if (shouldDrawFace(id, nb)) addFace(x,y,z,d,color);
            }
          }
        }
      }

      const geom=new THREE.BufferGeometry();
      geom.setAttribute("position",new THREE.Float32BufferAttribute(pos,3));
      geom.setAttribute("normal",new THREE.Float32BufferAttribute(norm,3));
      geom.setAttribute("color",new THREE.Float32BufferAttribute(col,3));
      geom.computeBoundingSphere();

      const mat=new THREE.MeshLambertMaterial({
        vertexColors:true,fog:true,
        transparent:true,opacity:1.0,
        depthWrite:true,side:THREE.FrontSide
      });

      c.mesh=new THREE.Mesh(geom,mat);
      scene.add(c.mesh);
    }

    let lastChunkX = Infinity, lastChunkZ = Infinity;
    function ensureChunk(cx,cz){
      const k = key(cx,cz);
      let ch = chunks.get(k);
      if(!ch){ ch=new Chunk(cx,cz); chunks.set(k,ch); }
      if(!ch.generated) generateChunk(ch);
      return ch;
    }
    function updateVisibleGridIfNeeded(wx,wz){
      const pcx=Math.floor(wx/CHUNK.X), pcz=Math.floor(wz/CHUNK.Z);
      if (pcx === lastChunkX && pcz === lastChunkZ) return;
      lastChunkX = pcx; lastChunkZ = pcz;
      for(let dz=-GRID_RADIUS;dz<=GRID_RADIUS;dz++){
        for(let dx=-GRID_RADIUS;dx<=GRID_RADIUS;dx++){
          buildMesh(ensureChunk(pcx+dx, pcz+dz));
        }
      }
    }
    function regenAll(){
      for(const [,ch] of chunks){
        if(ch.mesh){ scene.remove(ch.mesh); ch.mesh.geometry.dispose(); ch.mesh.material.dispose(); }
      }
      chunks.clear();
      lastChunkX = Infinity; lastChunkZ = Infinity;
      updateVisibleGridIfNeeded(camera.position.x,camera.position.z);
    }

    function getBlock(wx,wy,wz){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return BLOCK.AIR;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return BLOCK.AIR;
      return ch.blocks[idx(lx,ly,lz)];
    }
    function setBlock(wx,wy,wz,id){
      const cx=Math.floor(wx/CHUNK.X), cz=Math.floor(wz/CHUNK.Z);
      const ch=chunks.get(key(cx,cz)); if(!ch) return;
      const lx=wx-cx*CHUNK.X, ly=wy, lz=wz-cz*CHUNK.Z;
      if(lx<0||lx>=CHUNK.X||ly<0||ly>=CHUNK.Y||lz<0||lz>=CHUNK.Z) return;
      ch.blocks[idx(lx,ly,lz)]=id;
      ch.dirty = true;
    }

    /* ===== Physics ===== */
    const player = {
      pos: new THREE.Vector3(8, 50, 8),
      vel: new THREE.Vector3(),
      size: new THREE.Vector3(0.6, 1.8, 0.6),
      grounded: false
    };
    const GRAVITY = -0.007;
    const JUMP_VEL = 0.14;

    function isSolid(id){ return id!==BLOCK.AIR; }

    function aabbCollide(pos, size){
      const min = pos.clone().sub(size.clone().multiplyScalar(0.5));
      const max = pos.clone().add(size.clone().multiplyScalar(0.5));
      const minX=Math.floor(min.x), maxX=Math.floor(max.x);
      const minY=Math.floor(min.y), maxY=Math.floor(max.y);
      const minZ=Math.floor(min.z), maxZ=Math.floor(max.z);
      const boxes=[];
      for(let x=minX;x<=maxX;x++){
        for(let y=minY;y<=maxY;y++){
          for(let z=minZ;z<=maxZ;z++){
            if(isSolid(getBlock(x,y,z))){
              boxes.push({min:new THREE.Vector3(x,y,z), max:new THREE.Vector3(x+1,y+1,z+1)});
            }
          }
        }
      }
      return boxes;
    }

    function resolveCollisions(){
      player.grounded=false;
      const boxes=aabbCollide(player.pos, player.size);
      for(const b of boxes){
        const overlapX=Math.min(player.pos.x+player.size.x/2,b.max.x)-Math.max(player.pos.x-player.size.x/2,b.min.x);
        const overlapY=Math.min(player.pos.y+player.size.y/2,b.max.y)-Math.max(player.pos.y-player.size.y/2,b.min.y);
        const overlapZ=Math.min(player.pos.z+player.size.z/2,b.max.z)-Math.max(player.pos.z-player.size.z/2,b.min.z);
        if(overlapX>0 && overlapY>0 && overlapZ>0){
          const minOverlap=Math.min(overlapX, overlapY, overlapZ);
          if(minOverlap===overlapX){
            player.pos.x += (player.pos.x<b.min.x)? -overlapX: overlapX;
            player.vel.x=0;
          }else if(minOverlap===overlapY){
            player.pos.y += (player.pos.y<b.min.y)? -overlapY: overlapY;
            if(player.vel.y<0) player.grounded=true;
            player.vel.y=0;
          }else{
            player.pos.z += (player.pos.z<b.min.z)? -overlapZ: overlapZ;
            player.vel.z=0;
          }
        }
      }
    }

    /* ===== Loop ===== */
    updateVisibleGridIfNeeded(player.pos.x,player.pos.z);

    let last=performance.now();
    function animate(now){
      const dt=(now-last)/1000; last=now;
      camera.rotation.set(pitch,yaw,0,"YXZ");

      const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).multiplyScalar(-1);
      const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0));
      forward.normalize(); right.normalize();

      let speed=0.072;
      if(keys.has("shift")) speed=0.1; // sprint
      if(keys.has("w")) player.vel.addScaledVector(forward,speed);
      if(keys.has("s")) player.vel.addScaledVector(forward,-speed);
      if(keys.has("a")) player.vel.addScaledVector(right,-speed);
      if(keys.has("d")) player.vel.addScaledVector(right,speed);
      if(keys.has(" ")) { if(player.grounded){ player.vel.y=JUMP_VEL; player.grounded=false; } }

      player.vel.y += GRAVITY; // gravity
      player.pos.add(player.vel); // apply velocity
      resolveCollisions();       // fix overlaps
      player.vel.x*=0.7; player.vel.z*=0.7; // damping

      camera.position.copy(player.pos).add(new THREE.Vector3(0,player.size.y*0.4,0));

      updateVisibleGridIfNeeded(player.pos.x, player.pos.z);
      for (const [,ch] of chunks) buildMesh(ch);

      info.textContent=`Pos ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)} | grounded:${player.grounded}`;
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
